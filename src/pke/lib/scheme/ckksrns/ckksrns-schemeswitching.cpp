//==================================================================================
// BSD 2-Clause License
//
// Copyright (c) 2014-2022, NJIT, Duality Technologies Inc. and other contributors
//
// All rights reserved.
//
// Author TPOC: contact@openfhe.org
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
// 1. Redistributions of source code must retain the above copyright notice, this
//    list of conditions and the following disclaimer.
//
// 2. Redistributions in binary form must reproduce the above copyright notice,
//    this list of conditions and the following disclaimer in the documentation
//    and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//==================================================================================

/*
	CKKS to FHEW scheme switching implementation.
 */

#define PROFILE

#include "scheme/ckksrns/ckksrns-schemeswitching.h"

#include "cryptocontext.h"
#include "gen-cryptocontext.h"
#include "scheme/ckksrns/gen-cryptocontext-ckksrns.h"

#include "math/dftransform.h"

#include <iterator>

// Coefficients for the function (1.0/std::pow(2*Pi,1.0/8.0))*std::cos((2*Pi/8)*(x-0.25)) in [-16, 16]
static constexpr std::initializer_list<double> g_coefficients_sin2pi_16{
    0.2455457340168511,     -0.04791906488334782,   0.2838870204084082,     -0.02994453873551349,
    0.3557652261903648,     0.01510656188507299,    0.2953294667450001,     0.07120360233373937,
    -0.1034734733966807,    0.04499759051255525,    -0.4275071243192574,    -0.09034212972909554,
    0.367628762693249,      0.04931806603933471,    -0.14535986272412,      -0.01510693848306369,
    0.03595193549924024,    0.003103658218868759,   -0.006264460660707066,  -0.0004660943047712052,
    0.0008212879885240095,  5.391053389217882e-05,  -8.455154976914221e-05, -4.977380178602518e-06,
    7.04666204400644e-06,   3.765980757166835e-07,  -4.864851013612591e-07, -2.383026746930811e-08,
    2.832970640938316e-08,  1.28177429687131e-09,   -1.412145521045378e-09, -5.939145408994641e-11,
    6.099273252183116e-11,  2.397381728164642e-12,  -2.307402856353623e-12, -8.500921247536622e-14,
    7.704571444110577e-14,  2.704051671841271e-15,  -2.154585361348821e-15, -7.263493008564584e-16,
    -1.260761739828568e-16, 1.637108527837095e-16,  1.185492382226862e-16,  6.379078056744543e-16,
    -1.411300455031979e-16, 3.123678340470779e-16,  5.946279250534737e-16,  2.954322285866942e-16,
    -8.279629336187608e-17, 5.024229619913844e-16,  -3.293034395074617e-16, -1.189255850106947e-15,
    1.674743206637948e-16,  -1.524204491434537e-16, -7.90328254817908e-17,  3.95164127408954e-16,
    -1.317213758029847e-17, 8.016186584581639e-16,  -3.650563843682718e-16, 3.763467880085276e-16,
    -2.709696873661399e-16, -1.524204491434537e-16, -4.83605622590958e-16,  7.376397044967142e-16,
    1.234417464667971e-15,  -2.672062194860546e-16, -4.892508244110859e-17, -7.122362963061386e-16,
    3.763467880085276e-17,  -2.944913616166729e-16, -2.897870267665663e-16, 9.794425157921932e-16,
    -3.198947698072485e-17, 6.614294799249873e-16,  -5.7769231959309e-16,   6.586068790149234e-16,
    -4.629065492504889e-16, -5.127724986616189e-16, -3.236582376873337e-16, -1.64745806450733e-15,
    -9.408669700213192e-16, -4.986594941112991e-16, -1.209954923447416e-15, -1.373665776231126e-16,
    -2.314532746252445e-16, 3.217765037472911e-16,  3.481207789078881e-16,  8.223177317986329e-16,
    -9.766199148821293e-16, 6.19090466274028e-16,   1.209014056477395e-15,  -3.30244306477483e-16,
    5.974505259635377e-16,  5.993322599035803e-16,  1.829986256691466e-16,  -2.690879534260973e-16,
    8.618341445395283e-16,  -1.002023323072705e-16, 6.374373721894436e-16,  6.270878355192092e-16,
    1.199605386777182e-15,  -8.712428142397415e-16, -2.507410475106815e-16, -1.086230916889613e-15,
    1.072588345824304e-15,  -4.534978795502758e-16, 2.119067633230516e-15,  -1.842923177529259e-15,
    -1.814697168428619e-15, 4.243310034796149e-16,  4.224492695395723e-16,  1.531966643937213e-15,
    -2.850826919164597e-16, -8.958229638315484e-16, -5.02893395476395e-16,  1.096110020074837e-16,
    -6.975352498995555e-16, -8.743006318923108e-16};

// Coefficients for the function std::cos((2*Pi/8)*(x-0.25)) in [-16, 16]
static constexpr std::initializer_list<double> g_coefficients_sin_16{
    0.3089618642023512,     -0.06029493314747044,   0.3572054037078626,     -0.03767819688436892,
    0.4476473107637168,     0.01900807415933388,    0.3716030456190274,     0.08959307643050014,
    -0.1301971600693213,    0.05661894109070181,    -0.5379177065254969,    -0.1136744359614747,
    0.4625747961408903,     0.0620552488251422,     -0.1829013822914142,    -0.01900854801980488,
    0.04523710036341177,    0.003905227810159522,   -0.007882358256818644,  -0.0005864706461828454,
    0.001033398804492749,   6.783379527371902e-05,  -0.0001063883457082761, -6.262868564438644e-06,
    8.866575712296132e-06,  4.738605785311168e-07,  -6.121276942916985e-07, -2.998481738609274e-08,
    3.56463088274733e-08,   1.612813613357654e-09,  -1.776854714211309e-09, -7.472998491206746e-11,
    7.67445918490844e-11,   3.016634023557514e-12,  -2.90172217704093e-12,  -1.073642116830728e-13,
    9.678886694003313e-14,  4.314815924517769e-15,  -2.781202763383019e-15, 7.715109154174817e-17,
    2.822600910063957e-17,  9.389852360812764e-16,  5.645201820127915e-18,  1.157266373126222e-15,
    -5.325307050320666e-16, -6.755424844753071e-16, 2.822600910063957e-17,  -6.717790165952218e-16,
    1.524204491434537e-16,  3.462390449678454e-16,  3.048408982869074e-16,  -7.621022457172685e-16,
    -5.475845765524077e-16, 3.161313019271632e-16,  1.806464582440933e-16,  4.817238886509154e-16,
    -1.825281921841359e-16, -1.957003297644344e-16, 2.483888800856282e-16,  8.091455942183344e-17,
    -8.411350711990593e-16, 3.819919898286556e-16,  -8.16672529978505e-16,  1.336031097430273e-16,
    -2.427436782655003e-16, 2.352167425053298e-16,  1.337912831370316e-15,  1.106459556745071e-15,
    2.258080728051166e-17,  -2.634427516059693e-16, -1.659689335117607e-15, 2.276898067451592e-16,
    -2.841418249464384e-16, 9.879103185223851e-16,  -6.454347414346249e-16, -4.478526777301479e-16,
    -2.276898067451592e-16, 5.061864298714697e-16,  -4.280944713597002e-16, 1.571247839935603e-16,
    9.87910318522385e-17,   4.205675355995297e-16,  -4.290353383297215e-16, 2.747331552462252e-16,
    -6.322626038543264e-16, -3.622337834582079e-16, 6.698972826551792e-16,  -4.883099574410646e-16,
    -2.163994031049034e-16, 7.69629181477439e-16,   -3.349486413275896e-16, 2.013455315845623e-16,
    -5.795740535331326e-16, -1.608882518736456e-16, 4.469118107601266e-16,  9.992007221626409e-16,
    -2.83200957976417e-16,  1.11304562553522e-15,   -2.935504946466516e-16, 1.140330767665839e-15,
    -2.455662791755643e-16, 3.349486413275896e-16,  1.294632950749335e-15,  -4.417370424250093e-16,
    -2.065202999196795e-16, -7.051797940309786e-16, -8.576002431744323e-16, 2.784966231263105e-16,
    -4.939551592611925e-16, -1.124336029175476e-16, 4.833704058484527e-16,  1.086701350374624e-16,
    1.042480602783622e-15,  -4.290353383297215e-16, -4.657291501605529e-17, -1.058475341273984e-17,
    3.377712422376535e-16,  6.104462509869571e-16};

// Coefficients for the function (1.0/std::pow(2*Pi,1.0/8.0))*std::cos((2*Pi/8.0)*(x-0.25)) in [-128, 128]
static constexpr std::initializer_list<double> g_coefficients_sin2pi_128_9{
    0.08761193238226354,    -0.01738402917379392,   0.08935060894767313,    -0.01667686631436392,
    0.09435445639097996,    -0.01518333497826596,   0.1019473189108075,     -0.01276275748916528,
    0.110882655474149,      -0.009252446966171999,  0.1192111685574758,     -0.004534979909938953,
    0.1242004317120066,     0.001362904847617233,   0.1224283765086551,     0.008145596233693092,
    0.1102080588183085,     0.01512350467093644,    0.08449405378412403,    0.02114203679334985,
    0.04431786059830115,    0.02464956129638114,    -0.007454366487154669,  0.02400059020366966,
    -0.06266441339261235,   0.0180491215413637,     -0.1077943201829795,    0.00695836538813938,
    -0.1265848641500751,    -0.007067567033131986,  -0.1060856934163377,    -0.01966175019277508,
    -0.04512467324356773,   -0.02537595733026167,   0.03862916785371963,    -0.0201785566296389,
    0.1092652333753526,     -0.004612578019766411,  0.1263344585514989,     0.01438496124842956,
    0.07022427857484209,    0.02550072245548077,    -0.03434514153678107,   0.01979242584243335,
    -0.1194659697149694,    -0.001008794768691528,  -0.1149256786653964,    -0.02192904329965044,
    -0.01184295110147364,   -0.02417858011117596,   0.1066507410103885,     -0.003076473516323838,
    0.122343225763269,      0.02209885820126707,    0.005200840409852563,   0.02321022960558625,
    -0.1224755172356864,    -0.003930982569218595,  -0.1000653894904632,    -0.02689795846413602,
    0.05865754664309684,    -0.01297065380451242,   0.1377909895596227,     0.02083617539534925,
    0.006502421233003679,   0.02248299870285675,    -0.139660074659475,     -0.01399307934458518,
    -0.04589168496663835,   -0.0263421662574377,    0.1358978738303921,     0.01130242907664306,
    0.05563799538901031,    0.02715486116995984,    -0.1426236952996719,    -0.01461041285557406,
    -0.03302834981489188,   -0.02454368648125577,   0.1559877850928394,     0.02360418859443232,
    -0.03051465817859748,   0.01394389273916019,    -0.1434779685133351,    -0.0326137520114734,
    0.1272587840850199,     0.00968806150092634,    0.04489729856072615,    0.02496761251245225,
    -0.1723551233719199,    -0.03505277577503257,   0.1396636892583818,     0.01468861799711852,
    0.00597622458952793,    0.01686435635501478,    -0.1508869780062401,    -0.0392626068463298,
    0.2221665014327329,     0.04513725581939847,    -0.2157338005707834,    -0.03852627732394119,
    0.1657363840292956,     0.02705951812948022,    -0.1076077703571204,    -0.01637507278621027,
    0.06108202920758021,    0.00876339054415577,    -0.03094805600072437,   -0.004218297546715713,
    0.01419483272929196,    0.001848310901625205,   -0.005954927442783235,  -0.000743844834357433,
    0.002303049930851211,   0.000276890872388833,   -0.0008263094529170254, -9.587788269377866e-05,
    0.000276459761481133,   3.10280277328683e-05,   -8.662530848949058e-05, -9.421991495095434e-06,
    2.551403977799462e-05,  2.693817139509806e-06,  -7.08627853168575e-06,  -7.273160333789605e-07,
    1.861116908629967e-06,  1.859288982562724e-07,  -4.633601616493963e-07, -4.510790623761216e-08,
    1.096004151863654e-07,  1.040757606442787e-08,  -2.467843591423806e-08, -2.288015736340782e-09,
    5.299290810294302e-09,  4.800959747999802e-10,  -1.086991796689273e-09, -9.63033831430537e-11,
    2.133040952766737e-10,  1.849336626863696e-11,  -4.010173216641153e-11, -3.404204559101731e-12,
    7.232799297263385e-12,  6.027665442316686e-13,  -1.252868789531569e-12, -1.035300267428826e-13,
    2.072453780944445e-13,  1.81572061755555e-14,   -3.012503176280137e-14, -4.417490972407089e-16,
    3.698522891563647e-15,  -4.204154533937635e-16, -2.740777660720187e-15, -1.348919106364917e-15,
    -1.620799477984723e-15, 4.003965342611375e-16,  -5.245330582249314e-16, 1.754761547401069e-15,
    -5.0481471966847e-16,   -4.722624632690369e-16, 1.628901569091919e-16,  -1.219903204684612e-15};

// Coefficients for the function std::cos((2*Pi/8.0)*(x-0.25)) in [-128, 128]
static constexpr std::initializer_list<double> g_coefficients_sin_128_9{
    0.1102391212927243,     -0.02187373395994211,   0.1124268390107458,     -0.02098393493240529,
    0.1187230104366467,     -0.01910467513710662,   0.1282768516717666,     -0.01605894462798644,
    0.1395198824372532,     -0.01164204002381859,   0.1499993678111768,     -0.005706211320285595,
    0.1562771883214419,     0.001714896917823413,   0.1540474713960449,     0.01024932730954704,
    0.1386710603585185,     0.0190293926918098,     0.1063160004619134,     0.02660230741479622,
    0.05576366000710765,    0.03101570646459531,    -0.009379576377249907,  0.03019912816230817,
    -0.0788485047742673,    0.02271059711528932,    -0.1356339349470137,    0.008755475026793986,
    -0.1592774387394754,    -0.008892879750792294,  -0.1334840278710031,    -0.02473971302072592,
    -0.05677884497841732,   -0.03192970594284224,   0.04860577097972316,    -0.02538999302174102,
    0.137484735099641,      -0.005803850388491444,  0.1589623618726244,     0.01810010856669365,
    0.0883608265792938,     0.0320866936658363,     -0.04321532604907647,   0.02490413775604496,
    -0.1503199754606444,    -0.001269332222692847,  -0.1446070813135923,    -0.02759257099359443,
    -0.01490158346516776,   -0.03042308682260403,   0.1341950080829786,     -0.00387102222149273,
    0.1539403291028232,     0.02780624332141282,    0.006544040990494398,   0.02920464424364483,
    -0.1541067869730827,    -0.004946221963887387,  -0.1259088837478489,    -0.03384478831852274,
    0.07380680032154047,    -0.01632053350635859,   0.1733777260479963,     0.02621745239749425,
    0.008181775969439571,   0.02828959427825565,    -0.1757295323993279,    -0.01760701686610414,
    -0.05774394980002619,   -0.03314545384636128,   0.1709956827712282,     0.01422146294463732,
    0.07000740145088874,    0.03416804027493538,    -0.1794585556766005,    -0.0183837866729736,
    -0.04155845171244884,   -0.03088248777772008,   0.1962741363357263,     0.02970034946980074,
    -0.03839555883186283,   0.01754512702970762,    -0.18053345867049,      -0.04103677736631641,
    0.160125409323275,      0.01219015900976136,    0.05649274713125461,    0.03141589951629922,
    -0.2168686026455679,    -0.04410571819658609,   0.1757340805264673,     0.01848218954858542,
    0.00751968059011856,    0.02121984728783968,    -0.1898559638811217,    -0.04940280576755492,
    0.2795445692461527,     0.05679467720658034,    -0.2714505200535607,    -0.04847630731782693,
    0.2085404675461939,     0.03404807336268925,    -0.1353992056319448,    -0.02060419837768083,
    0.07685744445448736,    0.01102667692475582,    -0.03894088860353211,   -0.005307740649665444,
    0.0178608763033159,     0.002325666882698234,   -0.007492883113111434,  -0.0009359547117391121,
    0.002897849571021361,   0.0003484023880784909,  -0.001039717142728983,  -0.0001206398860581598,
    0.000347859935854049,   3.904151432138334e-05,  -0.0001089976859280163, -1.185537215132209e-05,
    3.210345039948186e-05,  3.389538688656318e-06,  -8.91642379620879e-06,  -9.151570842604238e-07,
    2.341780247951186e-06,  2.339480232858121e-07,  -5.830303637602153e-07, -5.675774787529067e-08,
    1.379064824815915e-07,  1.309549815214123e-08,  -3.105203846302873e-08, -2.878932963716673e-09,
    6.667918740964141e-09,  6.040889210814254e-10,  -1.36772558358343e-09,  -1.211755127456236e-10,
    2.683934899724452e-10,  2.327193993068022e-11,  -5.045808942629631e-11, -4.282885554144197e-12,
    9.098278347650196e-12,  7.554707520938225e-13,  -1.574942887745612e-12, -1.29096799388117e-13,
    2.611816186606642e-13,  2.112959278443598e-14,  -4.08360514715325e-14,  -2.949690756199039e-15,
    7.987327730435687e-15,  1.228514644510813e-15,  -2.193020897153918e-15, -5.501551595240731e-16,
    8.888392667385925e-17,  6.410216273133344e-17,  1.12310954187527e-15,   7.282534363910253e-16,
    -1.135996059125383e-15, -1.475836648657221e-15, -8.90326172575144e-16,  -2.060190642421979e-16,
    -7.310620363045115e-16, -1.418342956310561e-15, 7.624522706317109e-17,  4.922484377783711e-16,
    -1.033977797561985e-15, 2.03321982266453e-15,   8.301890920746148e-18,  1.186798675207561e-15};

// Coefficients for the function 1.0/(2*Pi) * std::asin(x) in [-1, 1]
static constexpr std::initializer_list<double> g_coefficients_asin128_4{0,
                                                                        0.2022153197342351,
                                                                        0,
                                                                        0.02207344731293696,
                                                                        1.189524669241239e-17,
                                                                        0.007630979223066646,
                                                                        1.586032892321652e-17,
                                                                        0.003607687659115019,
                                                                        2.775557561562891e-17,
                                                                        0.001893074937614354,
                                                                        2.577303450022685e-17,
                                                                        0.0009457107877224491,
                                                                        2.091580876749179e-16,
                                                                        0.0002892497106016072};

// Coefficients for the function 1.0/(2*Pi) * std::asin(x) in [-1, 1]
static constexpr std::initializer_list<double> g_coefficients_asin128_5{
    -3.96508223080413e-18, 0.2025359576197256,    3.568574007723717e-17, 0.02240846705512652,   1.784287003861859e-17,
    0.007996434161484033,  1.784287003861859e-17, 0.004023369936095595,  1.982541115402065e-17, 0.002385540438718644,
    1.189524669241239e-17, 0.001553268161876657,  1.586032892321652e-17, 0.001070986648967223,  -1.050746791163095e-16,
    0.0007643516298389452, 2.577303450022685e-17, 0.0005548468469477894, 3.172065784643304e-17, 0.0004027254950256024,
    2.874684617332994e-17, 0.0002859320976835662, 3.667701063493821e-17, 0.0001912069597735833, 2.478176394252581e-17,
    0.0001099118932402826, 9.764014993355171e-17, 3.587199157578286e-05};

// Coefficients for the function 1.0/(2*Pi) * std::asin(x) in [-1, 1]
static constexpr std::initializer_list<double> g_coefficients_asin128_6{
    7.809195851176949e-17,  0.2026184218638728,    4.986594941112992e-17,  0.0224918255945774,
    4.139814668093804e-17,  0.008081606270068029,  7.715109154174817e-17,  0.00411132623539181,
    1.006727657922811e-16,  0.002477332180945152,  3.198947698072485e-17,  0.001650061233373242,
    8.938236215202531e-17,  0.001174102579804449,  5.739288517130046e-17,  0.0008753186442488583,
    8.750062821198268e-17,  0.0006754651354034092, 4.986594941112992e-17,  0.000535152640229793,
    -4.986594941112992e-17, 0.0004327972897600613, 9.408669700213191e-18,  0.0003557668769256981,
    5.551115123125783e-17,  0.0002962679199527954, -6.86832888115563e-17,  0.0002492796115681422,
    -9.408669700213191e-19, 0.0002114480885665469, 7.809195851176949e-17,  0.0001804627775172313,
    8.561889427194003e-17,  0.0001546887355846373, 6.774242184153498e-17,  0.0001329415465672372,
    1.401891785331765e-16,  0.0001143448988646915, 9.408669700213191e-19,  9.82378389617415e-05,
    -5.174768335117255e-18, 8.411280229260206e-05, 7.762152502675883e-17,  7.157323410699735e-05,
    -9.690929791219587e-17, 6.030397788667019e-05, -7.573979108671618e-17, 5.005015767993566e-05,
    9.926146533724916e-17,  4.060181048657926e-05, -4.845464895609793e-17, 3.178246542345446e-05,
    1.390130948206499e-16,  2.344045682367051e-05, 1.51950015658443e-16,   1.544213523008295e-05,
    -1.679447541488055e-16, 7.666383254400478e-06, 2.249260100207216e-16};

// Coefficients for the function 1.0/(2*Pi) * std::asin(x) in [-1, 1]
static constexpr std::initializer_list<double> g_coefficients_asin128_7{
    2.239105259748215e-17,  0.2026364822189692,    7.463684199160716e-18,  0.02250993064963043,
    9.329605248950895e-18,  0.008099801005908795,  -7.930164461608261e-18, 0.00412965619808073,
    1.35279276109788e-17,   0.002495843773157369,  -3.312009863377568e-17, 0.001668802016514955,
    4.198322362027903e-18,  0.001193121590789431,  -2.70558552219576e-17,  0.0008946667311769855,
    3.312009863377568e-17,  0.000695195316799491,  2.145809207258706e-17,  0.0005553204930218876,
    -7.836868409118751e-17, 0.0004534613718350683, -9.329605248950895e-19, 0.0003769891909034637,
    -1.399440787342634e-17, 0.0003181144258131887, -4.291618414517411e-17, 0.0002718207969699351,
    -2.425697364727233e-17, 0.0002347596071776246, 5.224578939412501e-17,  0.0002046261674687382,
    3.778490125825113e-17,  0.0001797922323697754, 2.052513154769197e-17,  0.0001590810073977708,
    2.845529600930023e-17,  0.0001416248588176257, 7.930164461608261e-18,  0.0001267727233394742,
    -6.530723674265627e-18, 0.0001140283246895791, 4.198322362027903e-17,  0.0001030080159918424,
    -9.842733537643194e-17, 9.341143340327574e-05, -2.005865128524442e-17, 8.500069730830155e-05,
    6.997203936713171e-18,  7.758542977355614e-05, 1.56737368182375e-16,   7.101180100084866e-05,
    -1.278155919106273e-16, 6.515441243449882e-05, 4.991338808188729e-17,  5.991020694605188e-05,
    5.457819070636273e-17,  5.519384747323171e-05, -2.798881574685269e-18, 5.093417288295739e-05,
    -2.724244732693661e-16, 4.707145330183195e-05, -6.484075648020871e-17, 4.355524519673544e-05,
    -1.446088813587389e-17, 4.034270090295978e-05, 1.259496708608371e-17,  3.739722573868889e-05,
    3.032121705909041e-17,  3.468740327729588e-05, 2.518993417216742e-17,  3.218612921317831e-05,
    -1.026256577384598e-17, 2.986990871687795e-05, 5.457819070636273e-17,  2.771828285255987e-05,
    -1.072904603629353e-17, 2.571335756964666e-05, -1.520725655578996e-16, 2.383941473169699e-05,
    2.332401312237724e-17,  2.208258914511768e-05, -4.394244072255871e-16, 2.043059898769869e-05,
    5.714383214982423e-17,  1.887251966046226e-05, -1.446088813587389e-17, 1.73985931269035e-05,
    5.131282886922992e-17,  1.600006637994906e-05, 1.989538319338778e-16,  1.466905392172126e-05,
    -7.34706413354883e-17,  1.339842010396902e-05, 6.554047687388004e-17,  1.21816779561429e-05,
    1.851926641916753e-16,  1.10129017298731e-05,  4.699788644159014e-16,  9.886650892736334e-06,
    -2.024524339022344e-16, 8.79790367215746e-06,  3.043783712470229e-17,  7.741998588598783e-06,
    2.798881574685269e-18,  6.714582646392252e-06, -1.391277382749802e-16, 5.711565084590095e-06,
    -2.460683384410799e-17, 4.729075718934625e-06, -2.59246405855223e-16,  3.763427071072657e-06,
    -1.52713975918765e-16,  2.811079569647704e-06, 1.621018912005218e-17,  1.868609192616074e-06,
    6.355793575847797e-17,  9.32676993197407e-07,  1.151258710212339e-16};

// Coefficients for the function (1.0/std::pow(2*Pi,1.0/8.0))*std::cos((2*Pi/8)*(x-0.25)) in [-128, 128]
static constexpr std::initializer_list<double> g_coefficientsFHEW128_8{
    0.08761193238226316,   -0.01738402917379336,  0.08935060894767244,    -0.01667686631436463,
    0.09435445639098111,   -0.01518333497826755,  0.1019473189108072,     -0.01276275748916431,
    0.1108826554741485,    -0.009252446966171965, 0.1192111685574766,     -0.004534979909938414,
    0.1242004317120063,    0.001362904847616531,  0.1224283765086542,     0.008145596233693597,
    0.1102080588183091,    0.01512350467093634,   0.08449405378412286,    0.0211420367933498,
    0.04431786059830236,   0.02464956129638197,   -0.007454366487154326,  0.02400059020367153,
    -0.06266441339261325,  0.01804912154136471,   -0.1077943201829785,    0.006958365388139742,
    -0.1265848641500741,   -0.0070675670331342,   -0.106085693416339,     -0.01966175019277442,
    -0.04512467324356784,  -0.02537595733026223,  0.03862916785372085,    -0.02017855662963871,
    0.1092652333753524,    -0.004612578019766759, 0.1263344585514993,     0.01438496124843019,
    0.07022427857484083,   0.0255007224554796,    -0.03434514153678157,   0.01979242584243292,
    -0.11946596971497,     -0.001008794768691392, -0.1149256786653934,    -0.02192904329965151,
    -0.01184295110147355,  -0.02417858011117523,  0.1066507410103885,     -0.003076473516322313,
    0.1223432257632692,    0.02209885820126595,   0.005200840409852346,   0.02321022960558804,
    -0.1224755172356859,   -0.003930982569218327, -0.1000653894904625,    -0.02689795846413656,
    0.05865754664309863,   -0.01297065380451128,  0.1377909895596229,     0.02083617539534959,
    0.006502421233002613,  0.02248299870285587,   -0.1396600746594754,    -0.01399307934458612,
    -0.04589168496663812,  -0.02634216625743773,  0.1358978738303924,     0.01130242907664427,
    0.05563799538901153,   0.02715486116995834,   -0.1426236952996738,    -0.01461041285557356,
    -0.03302834981489244,  -0.02454368648125503,  0.1559877850928393,     0.02360418859443086,
    -0.03051465817859546,  0.01394389273915786,   -0.1434779685133353,    -0.03261375201147693,
    0.1272587840850199,    0.009688061500928326,  0.04489729856072647,    0.02496761251245012,
    -0.1723551233719205,   -0.03505277577503201,  0.1396636892583779,     0.01468861799712274,
    0.00597622458956165,   0.01686435635499905,   -0.1508869780064468,    -0.03926260684622877,
    0.2221665014339846,    0.04513725581879454,   -0.2157338005780159,    -0.03852627732054279,
    0.1657363840693942,    0.02705951811098896,   -0.1076077705704244,    -0.01637507268990577,
    0.06108203029457434,   0.008763390064060851,  -0.0309480613000186,    -0.004218295258698306,
    0.01419485740772727,   0.001848300494048352,  -0.005955037043198769,  -0.0007437997264540409,
    0.002303513291012029,  0.0002767049434903019, -0.0008281705698266399, -9.515056665995515e-05,
    0.0002835460400132129, 2.833421059389586e-05, -0.000112139348265277};

// Coefficients for the function std::pow(2/(5*Pi),1.0/8.0)*std::cos((2*Pi/8.0)*(x-0.25)) in [-16, 16]
static constexpr std::initializer_list<double> g_coefficients_sin2pi_4th_16{
    0.2387913779775442,     -0.04660092988666914,   0.2760779903779993,     -0.02912083851175566,
    0.3459790044353196,     0.0146910177180763,     0.2872056833069317,     0.06924496728202924,
    -0.1006271739781907,    0.04375981805257116,    -0.4157474603260956,    -0.08785704110809819,
    0.3575162043812014,     0.04796144797983876,    -0.1413613722979084,    -0.01469138395678731,
    0.03496298664359673,    0.003018284254957298,   -0.006092140836597429,  -0.0004532732028495985,
    0.0007986963865661707,  5.242758839728183e-05,  -8.222574568551596e-05, -4.840464755928963e-06,
    6.852825793735406e-06,  3.662387939227203e-07,  -4.731030996097217e-07, -2.317475614423819e-08,
    2.755042674786728e-08,  1.246516249918465e-09,  -1.373300845922932e-09, -5.775755015500921e-11,
    5.931458337676173e-11,  2.33150222292375e-12,   -2.242695671357377e-12, -8.298823022376043e-14,
    7.478763371305461e-14,  3.332550807815512e-15,  -2.141413223768522e-15, 4.704334850106595e-17,
    2.44625412205543e-17,   7.225858329763731e-16,  -7.526935760170553e-18, 8.862966857600826e-16,
    -4.102179989292951e-16, -5.268855032119387e-16, 1.129040364025583e-17,  -5.09949897751555e-16,
    1.129040364025583e-16,  2.766148891862678e-16,  2.333350085652872e-16,  -5.92746191113431e-16,
    -4.196266686295083e-16, 2.465071461455856e-16,  1.411300455031979e-16,  3.594111825481439e-16,
    -1.3548484368307e-16,   -1.543021830834963e-16, 1.881733940042638e-16,  5.645201820127914e-17,
    -6.548434111348381e-16, 3.029591643468647e-16,  -6.172087323339854e-16, 1.09140568522473e-16,
    -1.797055912740719e-16, 1.74060389453944e-16,   1.032131066113387e-15,  8.58070676659443e-16,
    1.97582063704477e-17,   -1.966411967344557e-16, -1.285224281049122e-15, 1.618291188436669e-16,
    -2.229854718950526e-16, 7.611613787472471e-16,  -5.005412280513418e-16, -3.565885816380799e-16,
    -1.608882518736456e-16, 3.942232604389327e-16,  -3.30244306477483e-16,  1.185492382226862e-16,
    7.338762366166289e-17,  3.264808385973977e-16,  -3.434164440577815e-16, 2.107542012847755e-16,
    -4.83605622590958e-16,  -2.709696873661399e-16, 5.221811683618321e-16,  -3.754059210385063e-16,
    -1.693560546038374e-16, 5.89923590203367e-16,   -2.577975497858414e-16, 1.552430500535177e-16,
    -4.403257419699773e-16, -1.209014056477395e-16, 3.53765980728016e-16,   7.752743832975669e-16,
    -2.135768021948394e-16, 8.496028739292511e-16,  -2.361576094753511e-16, 8.853558187900612e-16,
    -1.919368618843491e-16, 2.540340819057562e-16,  9.96378121252577e-16,   -3.340077743575683e-16,
    -1.613586853586562e-16, -5.541706453425569e-16, -6.658985980325886e-16, 2.145176691648608e-16,
    -3.805806893736236e-16, -8.420759381690806e-17, 3.561181481530693e-16,  8.37371603318974e-17,
    8.017362668294165e-16,  -3.255399716273764e-16, -3.928119599839007e-17, -4.527922293227598e-18,
    2.550925572470302e-16,  4.757846659026558e-16};

// Coefficients for the function std::pow(1/(std::pow(14,1.0/3.0)),1.0/8.0)*std::cos((2*Pi/8.0)*x) in [-16, 16]
static constexpr std::initializer_list<double> g_coefficients_cos2pi_4th_16{
    0.2822120819835678,     1.623351313317456e-16,
    0.3262787170721946,     2.369719733233527e-16,
    0.4088902036214871,     -2.033853944271295e-16,
    0.3394298174835472,     -1.100893419376206e-16,
    -0.1189247472543938,    1.306144734853125e-16,
    -0.4913450282490588,    4.664802624475448e-16,
    0.4225252738847615,     -4.235640783023706e-16,
    -0.1670658611132877,    2.985473679664286e-16,
    0.04132049212422154,    8.396644724055806e-17,
    -0.007199907148217225,  -5.411171044391519e-17,
    0.000943927590831574,   0,
    -9.717728956184613e-05, 5.485807886383127e-16,
    8.09891148976675e-06,   2.966814469166385e-16,
    -5.591299472867075e-07, 1.492736839832143e-16,
    3.256006740230257e-08,  6.605360516257234e-16,
    -1.62301512099231e-09,  -4.664802624475448e-17,
    7.009983443391079e-11,  -4.739439466467055e-16,
    -2.650695722674082e-12, -1.735306576304867e-16,
    8.845958512845281e-14,  3.54524999460134e-17,
    -2.552579996112965e-15, -3.172065784643304e-17,
    1.474077629334241e-16,  1.940557891781786e-16,
    -9.329605248950895e-17, -3.172065784643304e-16,
    9.702789458908931e-17,  4.59016578248384e-16,
    -7.799549988122948e-16, -1.45541841883634e-16,
    -3.078769732153795e-16, -3.209384205639108e-16,
    -4.38491446700692e-16,  1.679328944811161e-17,
    5.485807886383127e-16,  3.153406574145402e-16,
    -4.179663151530001e-16, -3.918434204559376e-17,
    1.884580260288081e-16,  -2.630948680204152e-16,
    -4.216981572525804e-16, -5.970947359328573e-17,
    7.389047357169108e-16,  1.865921049790179e-18,
    5.84033288584326e-16,   -3.713182889082456e-16,
    1.474077629334241e-16,  -1.679328944811161e-16,
    -1.100893419376206e-16, 1.369586050545991e-15,
    6.344131569286608e-17,  -1.192323550815924e-15,
    -6.791952621236251e-16, 3.02279210066009e-16,
    1.865921049790179e-17,  1.050513551031871e-15,
    -5.336534202399912e-16, 5.63508157036634e-16,
    1.725976971055916e-16,  2.649607890702054e-16,
    5.970947359328573e-17,  8.116756566587278e-17,
    1.884580260288081e-16,  -2.546982232963594e-16,
    -5.00066841343768e-16,  -1.949887497030737e-16,
    -1.324803945351027e-16, 4.179663151530001e-16,
    2.798881574685269e-18,  3.200054600390157e-16,
    -1.763295392051719e-15, -5.7377072281048e-16,
    -1.45728433988613e-15,  -2.052513154769197e-16,
    2.612289469706251e-17,  6.241505911548148e-16,
    -3.825138152069867e-17, -8.545918408039019e-16,
    -9.236309196461385e-16, -8.769828934013841e-17,
    -1.681194865860951e-15, 2.504999009343315e-16,
    3.601227626095046e-16,  9.18033156496768e-16,
    -3.815808546820916e-16, -3.727177296955883e-16,
    -5.910304925210392e-16, 4.445556901125102e-16,
    1.548714471325849e-16,  8.662538473650906e-16,
    -2.239105259748215e-16, -5.740039629417038e-16,
    -9.310946038452994e-16, -1.29285004737337e-15,
    2.085166773140525e-16,  -8.294019066317346e-16,
    -1.160369652838268e-16, 2.230941855155383e-16,
    3.20705180432687e-16,   -3.113172651509302e-16,
    6.099229431501648e-16};

// Coefficients for the function std::pow(2/(5*Pi),1.0/8.0)*std::cos((2*Pi/8.0)*(x-0.25)) in [-128, 128]
static constexpr std::initializer_list<double> g_coefficients_sin2pi_4th_128{
    0.08520194473995882,    -0.01690583751264507,   0.08689279461187063,    -0.01621812695504147,
    0.09175899858385685,    -0.01476567897329543,   0.09914300022885908,    -0.0124116855861232,
    0.1078325477756587,     -0.008997935026493499,  0.1159319640560289,     -0.004410233825199796,
    0.1207839849169627,     0.001325414704994628,   0.1190606745709097,     0.007921531021013823,
    0.1071765076059041,     0.01470749444979182,    0.08216983127320282,    0.02056047163413337,
    0.04309878582764927,    0.02397151281032227,    -0.007249315295761088,  0.02334039330781212,
    -0.06094067031581758,   0.01755263483360108,    -0.1048291649525454,    0.006766957960633938,
    -0.1231028275140888,    -0.006873155738370976,  -0.1031675382837332,    -0.01912090405798084,
    -0.04388340505186061,   -0.02467792748530058,   0.03756657495537189,    -0.0196234944275546,
    0.1062596169597792,     -0.004485697402885735,  0.1228593099544102,     0.01398926653081452,
    0.06829258229839368,    0.02479926063040009,    -0.03340039161030193,   0.01924798514360855,
    -0.1161797562636682,    -0.0009810453188144608, -0.111764357395152,     -0.02132582953729271,
    -0.01151718079796623,   -0.02351348715303619,   0.1037170428155329,     -0.002991847336365573,
    0.1189778661119961,     0.02149097325082592,    0.005057778149080381,   0.0225717735756438,
    -0.1191065185730931,    -0.00382285095796087,   -0.09731283803386059,   -0.02615806213107871,
    0.05704402256373863,    -0.01261386318785076,   0.1340007001203862,     0.02026302372696072,
    0.006323555701897402,   0.02186454699699144,    -0.1358183713103895,    -0.01360816432922946,
    -0.04462931817884049,   -0.02561755839380733,   0.1321596593242011,     0.01099152719761845,
    0.05410753169891494,    0.02640789807864553,    -0.1387004700742267,    -0.01420851652166819,
    -0.03211982157295917,   -0.0238685503495879,    0.1516969467994425,     0.02295489572675706,
    -0.02967527537856118,   0.01356033072570588,    -0.139531244343943,     -0.03171662833003609,
    0.1237582095778672,     0.009421566882441029,   0.04366228488436898,    0.0242808152238103,
    -0.1676140600701548,    -0.03408856058025991,   0.1358218864806182,     0.01428457043312785,
    0.00581183342708307,    0.01640045960823701,    -0.1467364503042214,    -0.03818258960745419,
    0.2160552502774548,     0.04389564151213867,    -0.2097994971115848,    -0.03746651468967793,
    0.1611773858822353,     0.02631517768947721,    -0.1046477466511574,    -0.01592463502067195,
    0.05940181360732563,    0.008522331337473182,   -0.03009675149816534,   -0.004102262610802264,
    0.01380436797715023,    0.001797468438606644,   -0.005791122112186926,  -0.000723383502098092,
    0.002239698721466993,   0.0002692742890921959,  -0.0008035797228899071, -9.324051919666621e-05,
    0.0002688550369797087,  3.017452340668692e-05,  -8.424246043025955e-05, -9.162815805371927e-06,
    2.48122116268408e-05,   2.619716890779611e-06,  -6.891352530381118e-06, -7.073093679914322e-07,
    1.809922184001916e-06,  1.808144558052005e-07,  -4.506142692796422e-07, -4.386709783997522e-08,
    1.065855796587856e-07,  1.012128859195771e-08,  -2.39995937307419e-08,  -2.225078935685909e-09,
    5.153521035611286e-09,  4.668898691273515e-10,  -1.057091301992497e-09, -9.365468990607528e-11,
    2.074364693904762e-10,  1.798624062188115e-11,  -3.899639604287852e-11, -3.309168911114213e-12,
    7.032018023434006e-12,  5.846004236254032e-13,  -1.218182152373792e-12, -9.835431080684743e-14,
    2.02726550824206e-13,   1.541648753100588e-14,  -3.38000460953225e-14,  -3.605796217165391e-15,
    4.644028217537511e-15,  3.481590016285452e-16,  -1.663773285809356e-15, -1.567496132892643e-15,
    -1.322726650432315e-16, 8.829742492721949e-17,  -1.823974998815814e-15, 3.507610868425104e-16,
    7.038640503775895e-17,  -3.253473879194502e-16, 1.829677902243087e-15,  -1.439365120148306e-15};

// Coefficients for the function std::pow(1/(std::pow(14,1.0/3.0)),1.0/8.0)*std::cos((2*Pi/8.0)*x) in [-128, 128]
static constexpr std::initializer_list<double> g_coefficients_cos2pi_4th_128{
    0.1006946666909125,     -5.412337245047639e-17, 0.1026929727717912,     2.928213227448851e-16,
    0.1084440244467815,     1.262878690511116e-16,  0.1171706983127122,     -6.800116025829084e-17,
    0.1274403124229349,     6.716849298982198e-16,  0.137012488565534,      4.538036613155328e-16,
    0.1427467781390898,     -9.658940314238863e-16, 0.1407101091237231,     -4.48252546192407e-16,
    0.1266649809861818,     6.855627177060342e-16,  0.09711120793494375,    2.914335439641036e-17,
    0.0509356668670367,     -3.469446951953614e-17, -0.008567496782754491,  -7.632783294297951e-17,
    -0.07202183593462265,   -3.719247132494275e-16, -0.1238908085560728,    -2.081668171172169e-17,
    -0.1454872681964345,    5.356826093816381e-16,  -0.1219270394884608,    6.106226635438361e-16,
    -0.05186295757034622,   -1.942890293094024e-17, 0.04439750472123118,    8.881784197001253e-17,
    0.1255813672460815,     5.648259637780484e-16,  0.1451994705460388,     1.429412144204889e-16,
    0.08071058510444212,    -4.815592369311617e-16, -0.03947376214017342,   5.870304242705516e-16,
    -0.1373053381458204,    6.619704784327496e-16,  -0.132087063859598,     7.632783294297951e-17,
    -0.01361141092741158,   2.775557561562891e-16,  0.1225764633466078,     -6.411537967210279e-16,
    0.1406122431630936,     -1.344757638577221e-15, 0.005977460801776657,   1.136590821460004e-15,
    -0.1407642891842101,    -3.747002708109904e-17, -0.115007748009428,     -1.465494392505207e-15,
    0.06741664003439933,    1.103284130721249e-15,  0.1583667588357652,     9.68669588985449e-16,
    0.007473401407060676,   -1.4585554986013e-15,   -0.1605149468283018,    7.591149930874508e-16,
    -0.0527445040412726,    1.364186541508161e-15,  0.1561909518174869,     8.0629947163402e-16,
    0.06394619144573492,    -5.231926003546051e-16, -0.1639211129114878,    -6.591949208711867e-16,
    -0.03796033925436743,   8.729128531115294e-16,  0.1792808079982134,     3.140543380908412e-15,
    -0.03507128824729686,   -8.049116928532385e-16, -0.1649029512772654,    -2.116362640691705e-15,
    0.1462618218603065,     1.387778780781446e-18,  0.05160162994886772,    1.579292252529285e-15,
    -0.1980922144792243,    1.068589661201713e-15,  0.1605191011805943,     4.413136522884997e-16,
    0.006868629954273281,   -3.413935800722357e-16, -0.1734183180898892,    -2.334243909274392e-15,
    0.2553417234771984,     -2.600697435184429e-15, -0.2479484535012555,    -2.176037128265307e-15,
    0.1904851256512787,     -1.364880430898552e-15, -0.1236764020017902,    3.150257832373882e-16,
    0.07020316074100338,    -9.96425164601078e-16,  -0.03556940360735206,   -2.671474153004283e-16,
    0.01631448949411136,    1.061650767297806e-15,  -0.006844152591033337,  -1.41067713066434e-15,
    0.002646955030597904,   -1.984523656517467e-16, -0.0009496988901237874, 3.441691376337985e-16,
    0.0003177423757115862,  -3.011479954295738e-16, -9.956071425488572e-05, -5.620504062164855e-17,
    2.932394779497569e-05,  4.503342143635792e-16,  -8.144443747677699e-06, 4.600486658290492e-16,
    2.13902994387824e-06,   2.29399832463173e-15,   -5.325518543708441e-07, 1.106753577673203e-15,
    1.259666010701432e-07,  4.544975507059235e-16,  -2.836356811503071e-08, -8.486267244478541e-16,
    6.090612767947757e-09,  -5.273559366969494e-16, -1.249307911982411e-09, -4.926614671774132e-16,
    2.451552374299615e-10,  1.85268467234323e-15,   -4.608747862511198e-11, 1.611905053877649e-15,
    8.310445387404998e-12,  -5.159067617555025e-16, -1.43939513086444e-12,  1.454392162258955e-15,
    2.402598953121782e-13,  -6.553785292240377e-16, -3.975014761792295e-14, -1.63948715714568e-15,
    5.732393726365359e-15,  -4.246603069191224e-16, -1.701416785238053e-15, -1.352563894219117e-15,
    6.505213034913027e-16,  1.775489477662262e-16,  -1.63948715714568e-15,  2.998469528225911e-16,
    -6.713379852030244e-17, -1.389513504257423e-16, 1.85793221085806e-15,   -1.453828377129263e-15};

namespace lbcrypto {

//------------------------------------------------------------------------------
// Complex Plaintext Functions, copied from ckksrns-fhe. TODO: fix this
//------------------------------------------------------------------------------

#if NATIVEINT == 128 && !defined(__EMSCRIPTEN__)
Plaintext SWITCHCKKSRNS::MakeAuxPlaintext(const CryptoContextImpl<DCRTPoly>& cc, const std::shared_ptr<ParmType> params,
                                          const std::vector<std::complex<double>>& value, size_t noiseScaleDeg,
                                          uint32_t level, usint slots) const {
    const auto cryptoParams = std::dynamic_pointer_cast<CryptoParametersCKKSRNS>(cc.GetCryptoParameters());

    double scFact = cryptoParams->GetScalingFactorReal(level);

    Plaintext p = Plaintext(std::make_shared<CKKSPackedEncoding>(params, cc.GetEncodingParams(), value, noiseScaleDeg,
                                                                 level, scFact, slots));

    DCRTPoly& plainElement = p->GetElement<DCRTPoly>();

    usint N = cc.GetRingDimension();

    std::vector<std::complex<double>> inverse = value;

    inverse.resize(slots);

    DiscreteFourierTransform::FFTSpecialInv(inverse, N * 2);
    uint64_t pBits = cc.GetEncodingParams()->GetPlaintextModulus();

    double powP      = std::pow(2.0, MAX_DOUBLE_PRECISION);
    int32_t pCurrent = pBits - MAX_DOUBLE_PRECISION;

    std::vector<int128_t> temp(2 * slots);
    for (size_t i = 0; i < slots; ++i) {
        // extract the mantissa of real part and multiply it by 2^52
        int32_t n1 = 0;
        double dre = std::frexp(inverse[i].real(), &n1) * powP;
        // extract the mantissa of imaginary part and multiply it by 2^52
        int32_t n2 = 0;
        double dim = std::frexp(inverse[i].imag(), &n2) * powP;

        // Check for possible overflow
        if (is128BitOverflow(dre) || is128BitOverflow(dim)) {
            DiscreteFourierTransform::FFTSpecial(inverse, N * 2);

            double invLen = static_cast<double>(inverse.size());
            double factor = 2 * M_PI * i;

            double realMax = -1, imagMax = -1;
            uint32_t realMaxIdx = -1, imagMaxIdx = -1;

            for (uint32_t idx = 0; idx < inverse.size(); idx++) {
                // exp( j*2*pi*n*k/N )
                std::complex<double> expFactor = {cos((factor * idx) / invLen), sin((factor * idx) / invLen)};

                // X[k] * exp( j*2*pi*n*k/N )
                std::complex<double> prodFactor = inverse[idx] * expFactor;

                double realVal = prodFactor.real();
                double imagVal = prodFactor.imag();

                if (realVal > realMax) {
                    realMax    = realVal;
                    realMaxIdx = idx;
                }
                if (imagVal > imagMax) {
                    imagMax    = imagVal;
                    imagMaxIdx = idx;
                }
            }

            auto scaledInputSize = ceil(log2(dre));

            std::stringstream buffer;
            buffer << std::endl
                   << "Overflow in data encoding - scaled input is too large to fit "
                      "into a NativeInteger (60 bits). Try decreasing scaling factor."
                   << std::endl;
            buffer << "Overflow at slot number " << i << std::endl;
            buffer << "- Max real part contribution from input[" << realMaxIdx << "]: " << realMax << std::endl;
            buffer << "- Max imaginary part contribution from input[" << imagMaxIdx << "]: " << imagMax << std::endl;
            buffer << "Scaling factor is " << ceil(log2(powP)) << " bits " << std::endl;
            buffer << "Scaled input is " << scaledInputSize << " bits " << std::endl;
            OPENFHE_THROW(buffer.str());
        }

        int64_t re64       = std::llround(dre);
        int32_t pRemaining = pCurrent + n1;
        __int128 re        = 0;
        if (pRemaining < 0) {
            re = re64 >> (-pRemaining);
        }
        else {
            __int128 pPowRemaining = ((__int128)1) << pRemaining;
            re                     = pPowRemaining * re64;
        }

        int64_t im64 = std::llround(dim);
        pRemaining   = pCurrent + n2;
        __int128 im  = 0;
        if (pRemaining < 0) {
            im = im64 >> (-pRemaining);
        }
        else {
            __int128 pPowRemaining = ((int64_t)1) << pRemaining;
            im                     = pPowRemaining * im64;
        }

        temp[i]         = (re < 0) ? Max128BitValue() + re : re;
        temp[i + slots] = (im < 0) ? Max128BitValue() + im : im;

        if (is128BitOverflow(temp[i]) || is128BitOverflow(temp[i + slots])) {
            OPENFHE_THROW("Overflow, try to decrease scaling factor");
        }
    }

    const std::shared_ptr<ILDCRTParams<BigInteger>> bigParams        = plainElement.GetParams();
    const std::vector<std::shared_ptr<ILNativeParams>>& nativeParams = bigParams->GetParams();

    for (size_t i = 0; i < nativeParams.size(); i++) {
        NativeVector nativeVec(N, nativeParams[i]->GetModulus());
        FitToNativeVector(N, temp, Max128BitValue(), &nativeVec);
        NativePoly element = plainElement.GetElementAtIndex(i);
        element.SetValues(nativeVec, Format::COEFFICIENT);
        plainElement.SetElementAtIndex(i, element);
    }

    usint numTowers = nativeParams.size();
    std::vector<DCRTPoly::Integer> moduli(numTowers);
    for (usint i = 0; i < numTowers; i++) {
        moduli[i] = nativeParams[i]->GetModulus();
    }

    DCRTPoly::Integer intPowP = NativeInteger(1) << pBits;
    std::vector<DCRTPoly::Integer> crtPowP(numTowers, intPowP);

    auto currPowP = crtPowP;

    // We want to scale temp by 2^(pd), and the loop starts from j=2
    // because temp is already scaled by 2^p in the re/im loop above,
    // and currPowP already is 2^p.
    for (size_t i = 2; i < noiseScaleDeg; i++) {
        currPowP = CKKSPackedEncoding::CRTMult(currPowP, crtPowP, moduli);
    }

    if (noiseScaleDeg > 1) {
        plainElement = plainElement.Times(currPowP);
    }

    p->SetFormat(Format::EVALUATION);
    p->SetScalingFactor(pow(p->GetScalingFactor(), noiseScaleDeg));

    return p;
}
#else
Plaintext SWITCHCKKSRNS::MakeAuxPlaintext(const CryptoContextImpl<DCRTPoly>& cc, const std::shared_ptr<ParmType> params,
                                          const std::vector<std::complex<double>>& value, size_t noiseScaleDeg,
                                          uint32_t level, usint slots) const {
    const auto cryptoParams = std::dynamic_pointer_cast<CryptoParametersCKKSRNS>(cc.GetCryptoParameters());

    double scFact = cryptoParams->GetScalingFactorReal(level);

    Plaintext p = Plaintext(std::make_shared<CKKSPackedEncoding>(params, cc.GetEncodingParams(), value, noiseScaleDeg,
                                                                 level, scFact, slots));

    DCRTPoly& plainElement = p->GetElement<DCRTPoly>();

    usint N = cc.GetRingDimension();

    std::vector<std::complex<double>> inverse = value;

    inverse.resize(slots);

    DiscreteFourierTransform::FFTSpecialInv(inverse, N * 2);
    double powP = scFact;

    // Compute approxFactor, a value to scale down by, in case the value exceeds a 64-bit integer.
    constexpr int32_t MAX_BITS_IN_WORD = 61;

    int32_t logc = 0;
    for (size_t i = 0; i < slots; ++i) {
        inverse[i] *= powP;
        if (inverse[i].real() != 0) {
            int32_t logci = static_cast<int32_t>(ceil(log2(std::abs(inverse[i].real()))));
            if (logc < logci)
                logc = logci;
        }
        if (inverse[i].imag() != 0) {
            int32_t logci = static_cast<int32_t>(ceil(log2(std::abs(inverse[i].imag()))));
            if (logc < logci)
                logc = logci;
        }
    }
    if (logc < 0) {
        OPENFHE_THROW("Too small scaling factor");
    }
    int32_t logValid    = (logc <= MAX_BITS_IN_WORD) ? logc : MAX_BITS_IN_WORD;
    int32_t logApprox   = logc - logValid;
    double approxFactor = pow(2, logApprox);

    std::vector<int64_t> temp(2 * slots);
    for (size_t i = 0; i < slots; ++i) {
        // Scale down by approxFactor in case the value exceeds a 64-bit integer.
        double dre = inverse[i].real() / approxFactor;
        double dim = inverse[i].imag() / approxFactor;

        // Check for possible overflow
        if (is64BitOverflow(dre) || is64BitOverflow(dim)) {
            DiscreteFourierTransform::FFTSpecial(inverse, N * 2);

            double invLen = static_cast<double>(inverse.size());
            double factor = 2 * M_PI * i;

            double realMax = -1;
            double imagMax = -1;
            // TODO (dsuponit): is this correct - "uint32_t realMaxIdx = -1" and "uint32_t imagMaxIdx = -1"? if yes,
            // TODO (dsuponit): shouldn't it better be "uint32_t realMaxIdx = std::numeric_limits<uint32_t>::max()"?"
            uint32_t realMaxIdx = -1;
            uint32_t imagMaxIdx = -1;

            for (uint32_t idx = 0; idx < inverse.size(); idx++) {
                // exp( j*2*pi*n*k/N )
                std::complex<double> expFactor = {cos((factor * idx) / invLen), sin((factor * idx) / invLen)};

                // X[k] * exp( j*2*pi*n*k/N )
                std::complex<double> prodFactor = inverse[idx] * expFactor;

                double realVal = prodFactor.real();
                double imagVal = prodFactor.imag();

                if (realVal > realMax) {
                    realMax    = realVal;
                    realMaxIdx = idx;
                }
                if (imagVal > imagMax) {
                    imagMax    = imagVal;
                    imagMaxIdx = idx;
                }
            }

            auto scaledInputSize = ceil(log2(dre));

            std::stringstream buffer;
            buffer << std::endl
                   << "Overflow in data encoding - scaled input is too large to fit "
                      "into a NativeInteger (60 bits). Try decreasing scaling factor."
                   << std::endl;
            buffer << "Overflow at slot number " << i << std::endl;
            buffer << "- Max real part contribution from input[" << realMaxIdx << "]: " << realMax << std::endl;
            buffer << "- Max imaginary part contribution from input[" << imagMaxIdx << "]: " << imagMax << std::endl;
            buffer << "Scaling factor is " << ceil(log2(powP)) << " bits " << std::endl;
            buffer << "Scaled input is " << scaledInputSize << " bits " << std::endl;
            OPENFHE_THROW(buffer.str());
        }

        int64_t re = std::llround(dre);
        int64_t im = std::llround(dim);

        temp[i]         = (re < 0) ? Max64BitValue() + re : re;
        temp[i + slots] = (im < 0) ? Max64BitValue() + im : im;
    }

    const std::shared_ptr<ILDCRTParams<BigInteger>> bigParams        = plainElement.GetParams();
    const std::vector<std::shared_ptr<ILNativeParams>>& nativeParams = bigParams->GetParams();

    for (size_t i = 0; i < nativeParams.size(); i++) {
        NativeVector nativeVec(N, nativeParams[i]->GetModulus());
        FitToNativeVector(N, temp, Max64BitValue(), &nativeVec);
        NativePoly element = plainElement.GetElementAtIndex(i);
        element.SetValues(nativeVec, Format::COEFFICIENT);
        plainElement.SetElementAtIndex(i, element);
    }

    usint numTowers = nativeParams.size();
    std::vector<DCRTPoly::Integer> moduli(numTowers);
    for (usint i = 0; i < numTowers; i++) {
        moduli[i] = nativeParams[i]->GetModulus();
    }

    DCRTPoly::Integer intPowP = std::llround(powP);
    std::vector<DCRTPoly::Integer> crtPowP(numTowers, intPowP);

    auto currPowP = crtPowP;

    // We want to scale temp by 2^(pd), and the loop starts from j=2
    // because temp is already scaled by 2^p in the re/im loop above,
    // and currPowP already is 2^p.
    for (size_t i = 2; i < noiseScaleDeg; i++) {
        currPowP = CKKSPackedEncoding::CRTMult(currPowP, crtPowP, moduli);
    }

    if (noiseScaleDeg > 1) {
        plainElement = plainElement.Times(currPowP);
    }

    // Scale back up by the approxFactor to get the correct encoding.
    if (logApprox > 0) {
        int32_t logStep = (logApprox <= MAX_LOG_STEP) ? logApprox : MAX_LOG_STEP;
        auto intStep    = DCRTPoly::Integer(uint64_t(1) << logStep);
        std::vector<DCRTPoly::Integer> crtApprox(numTowers, intStep);
        logApprox -= logStep;

        while (logApprox > 0) {
            logStep = (logApprox <= MAX_LOG_STEP) ? logApprox : MAX_LOG_STEP;
            intStep = DCRTPoly::Integer(uint64_t(1) << logStep);
            std::vector<DCRTPoly::Integer> crtSF(numTowers, intStep);
            crtApprox = CKKSPackedEncoding::CRTMult(crtApprox, crtSF, moduli);
            logApprox -= logStep;
        }
        plainElement = plainElement.Times(crtApprox);
    }

    p->SetFormat(Format::EVALUATION);
    p->SetScalingFactor(pow(p->GetScalingFactor(), noiseScaleDeg));

    return p;
}
#endif

Ciphertext<DCRTPoly> SWITCHCKKSRNS::EvalMultExt(ConstCiphertext<DCRTPoly> ciphertext, ConstPlaintext plaintext) const {
    Ciphertext<DCRTPoly> result = ciphertext->Clone();
    std::vector<DCRTPoly>& cv   = result->GetElements();

    DCRTPoly pt = plaintext->GetElement<DCRTPoly>();
    pt.SetFormat(Format::EVALUATION);

    for (auto& c : cv) {
        c *= pt;
    }
    result->SetNoiseScaleDeg(result->GetNoiseScaleDeg() + plaintext->GetNoiseScaleDeg());
    result->SetScalingFactor(result->GetScalingFactor() * plaintext->GetScalingFactor());
    return result;
}

void SWITCHCKKSRNS::EvalAddExtInPlace(Ciphertext<DCRTPoly>& ciphertext1, ConstCiphertext<DCRTPoly> ciphertext2) const {
    std::vector<DCRTPoly>& cv1       = ciphertext1->GetElements();
    const std::vector<DCRTPoly>& cv2 = ciphertext2->GetElements();

    for (size_t i = 0; i < cv1.size(); ++i) {
        cv1[i] += cv2[i];
    }
}

Ciphertext<DCRTPoly> SWITCHCKKSRNS::EvalAddExt(ConstCiphertext<DCRTPoly> ciphertext1,
                                               ConstCiphertext<DCRTPoly> ciphertext2) const {
    Ciphertext<DCRTPoly> result = ciphertext1->Clone();
    EvalAddExtInPlace(result, ciphertext2);
    return result;
}

EvalKey<DCRTPoly> SWITCHCKKSRNS::ConjugateKeyGen(const PrivateKey<DCRTPoly> privateKey) const {
    const auto cc = privateKey->GetCryptoContext();
    auto algo     = cc->GetScheme();

    const DCRTPoly& s = privateKey->GetPrivateElement();
    usint N           = s.GetRingDimension();

    PrivateKey<DCRTPoly> privateKeyPermuted = std::make_shared<PrivateKeyImpl<DCRTPoly>>(cc);

    usint index = 2 * N - 1;
    std::vector<usint> vec(N);
    PrecomputeAutoMap(N, index, &vec);

    DCRTPoly sPermuted = s.AutomorphismTransform(index, vec);

    privateKeyPermuted->SetPrivateElement(sPermuted);
    privateKeyPermuted->SetKeyTag(privateKey->GetKeyTag());

    return algo->KeySwitchGen(privateKey, privateKeyPermuted);
}

Ciphertext<DCRTPoly> SWITCHCKKSRNS::Conjugate(ConstCiphertext<DCRTPoly> ciphertext,
                                              const std::map<usint, EvalKey<DCRTPoly>>& evalKeyMap) const {
    const std::vector<DCRTPoly>& cv = ciphertext->GetElements();
    usint N                         = cv[0].GetRingDimension();

    std::vector<usint> vec(N);
    PrecomputeAutoMap(N, 2 * N - 1, &vec);

    auto algo = ciphertext->GetCryptoContext()->GetScheme();

    Ciphertext<DCRTPoly> result = ciphertext->Clone();

    algo->KeySwitchInPlace(result, evalKeyMap.at(2 * N - 1));

    std::vector<DCRTPoly>& rcv = result->GetElements();

    rcv[0] = rcv[0].AutomorphismTransform(2 * N - 1, vec);
    rcv[1] = rcv[1].AutomorphismTransform(2 * N - 1, vec);

    return result;
}

#if NATIVEINT == 128 && !defined(__EMSCRIPTEN__)
void SWITCHCKKSRNS::FitToNativeVector(uint32_t ringDim, const std::vector<__int128>& vec, __int128 bigBound,
                                      NativeVector* nativeVec) const {
    if (nativeVec == nullptr)
        OPENFHE_THROW("The passed native vector is empty.");
    NativeInteger bigValueHf((unsigned __int128)bigBound >> 1);
    NativeInteger modulus(nativeVec->GetModulus());
    NativeInteger diff = NativeInteger((unsigned __int128)bigBound) - modulus;
    uint32_t dslots    = vec.size();
    uint32_t gap       = ringDim / dslots;
    for (usint i = 0; i < vec.size(); i++) {
        NativeInteger n((unsigned __int128)vec[i]);
        if (n > bigValueHf) {
            (*nativeVec)[gap * i] = n.ModSub(diff, modulus);
        }
        else {
            (*nativeVec)[gap * i] = n.Mod(modulus);
        }
    }
}
#else  // NATIVEINT == 64
void SWITCHCKKSRNS::FitToNativeVector(uint32_t ringDim, const std::vector<int64_t>& vec, int64_t bigBound,
                                      NativeVector* nativeVec) const {
    if (nativeVec == nullptr)
        OPENFHE_THROW("The passed native vector is empty.");
    NativeInteger bigValueHf(bigBound >> 1);
    NativeInteger modulus(nativeVec->GetModulus());
    NativeInteger diff = bigBound - modulus;
    uint32_t dslots    = vec.size();
    uint32_t gap       = ringDim / dslots;
    for (usint i = 0; i < vec.size(); i++) {
        NativeInteger n(vec[i]);
        if (n > bigValueHf) {
            (*nativeVec)[gap * i] = n.ModSub(diff, modulus);
        }
        else {
            (*nativeVec)[gap * i] = n.Mod(modulus);
        }
    }
}
#endif

//------------------------------------------------------------------------------
// Key and modulus switch and extraction methods
//------------------------------------------------------------------------------

NativeInteger RoundqQAlter(const NativeInteger& v, const NativeInteger& q, const NativeInteger& Q) {
    return NativeInteger(
               (BasicInteger)std::floor(0.5 + v.ConvertToDouble() * q.ConvertToDouble() / Q.ConvertToDouble()))
        .Mod(q);
}

EvalKey<DCRTPoly> switchingKeyGenRLWE(
    const PrivateKey<DCRTPoly>& ckksSK,
    ConstLWEPrivateKey& LWEsk) {  // This function is without the intermediate ModSwitch
    // Extract CKKS params: method which populates the first n elements of a new RLWE key with the n elements of the target LWE key
    auto skelements = ckksSK->GetPrivateElement();
    skelements.SetFormat(Format::COEFFICIENT);
    auto lweskElements = LWEsk->GetElement();
    for (size_t i = 0; i < skelements.GetNumOfElements(); i++) {
        auto skelementsPlain = skelements.GetElementAtIndex(i);
        for (size_t j = 0; j < skelementsPlain.GetLength(); j++) {
            if (j >= lweskElements.GetLength()) {
                skelementsPlain[j] = 0;
            }
            else {
                if (lweskElements[j] == 0) {
                    skelementsPlain[j] = 0;
                }
                else if (lweskElements[j].ConvertToInt() == 1) {
                    skelementsPlain[j] = 1;
                }
                else
                    skelementsPlain[j] = skelementsPlain.GetModulus() - 1;
            }
        }
        skelements.SetElementAtIndex(i, skelementsPlain);
    }

    skelements.SetFormat(Format::EVALUATION);

    auto ccCKKS    = ckksSK->GetCryptoContext();
    auto RLWELWEsk = ccCKKS->KeyGen().secretKey;
    RLWELWEsk->SetPrivateElement(std::move(skelements));

    return ccCKKS->KeySwitchGen(ckksSK, RLWELWEsk);
}

void ModSwitch(ConstCiphertext<DCRTPoly> ctxt, Ciphertext<DCRTPoly>& ctxtKS, NativeInteger modulus_CKKS_to) {
    if (ctxt->GetElements()[0].GetRingDimension() != ctxtKS->GetElements()[0].GetRingDimension()) {
        OPENFHE_THROW("ModSwitch is implemented only for the same ring dimension.");
    }

    const std::vector<DCRTPoly>& cv = ctxt->GetElements();

    if (cv[0].GetNumOfElements() != 1 || ctxtKS->GetElements()[0].GetNumOfElements() != 1) {
        OPENFHE_THROW("ModSwitch is implemented only for ciphertext with one tower.");
    }

    const auto& paramsQlP = ctxtKS->GetElements()[0].GetParams();
    std::vector<DCRTPoly> resultElements;
    resultElements.reserve(cv.size());

    for (const auto& elem : cv) {
        auto& ref = resultElements.emplace_back(paramsQlP, Format::COEFFICIENT, true);
        ref.SetValuesModSwitch(elem, modulus_CKKS_to);
        ref.SetFormat(Format::EVALUATION);
    }

    ctxtKS->SetElements(resultElements);
}

EvalKey<DCRTPoly> switchingKeyGen(const PrivateKey<DCRTPoly>& ckksSKto, const PrivateKey<DCRTPoly>& ckksSKfrom) {
    auto skElements = ckksSKto->GetPrivateElement();
    skElements.SetFormat(Format::COEFFICIENT);
    auto skElementsFrom = ckksSKfrom->GetPrivateElement();
    skElementsFrom.SetFormat(Format::COEFFICIENT);

    for (size_t i = 0; i < skElements.GetNumOfElements(); i++) {
        auto skElementsPlain     = skElements.GetElementAtIndex(i);
        auto skElementsFromPlain = skElementsFrom.GetElementAtIndex(i);
        for (size_t j = 0; j < skElementsPlain.GetLength(); j++) {
            if (skElementsFromPlain[j] == 0) {
                skElementsPlain[j] = 0;
            }
            else if (skElementsFromPlain[j] == 1) {
                skElementsPlain[j] = 1;
            }
            else
                skElementsPlain[j] = skElementsPlain.GetModulus() - 1;
        }
        skElements.SetElementAtIndex(i, skElementsPlain);
    }

    skElements.SetFormat(Format::EVALUATION);

    auto ccCKKSto        = ckksSKto->GetCryptoContext();
    auto oldTranformedSK = ccCKKSto->KeyGen().secretKey;
    oldTranformedSK->SetPrivateElement(std::move(skElements));

    return ccCKKSto->KeySwitchGen(oldTranformedSK, ckksSKto);
}

EvalKey<DCRTPoly> switchingKeyGenRLWEcc(const PrivateKey<DCRTPoly>& ckksSKto, const PrivateKey<DCRTPoly>& ckksSKfrom,
                                        ConstLWEPrivateKey& LWEsk) {
    auto skElements = ckksSKto->GetPrivateElement();
    skElements.SetFormat(Format::COEFFICIENT);
    auto skElementsFrom = ckksSKfrom->GetPrivateElement();
    skElementsFrom.SetFormat(Format::COEFFICIENT);
    auto skElements2 = ckksSKto->GetPrivateElement();
    skElements2.SetFormat(Format::COEFFICIENT);
    auto lweskElements = LWEsk->GetElement();

    for (size_t i = 0; i < skElements.GetNumOfElements(); i++) {
        auto skElementsPlain     = skElements.GetElementAtIndex(i);
        auto skElementsFromPlain = skElementsFrom.GetElementAtIndex(i);
        auto skElementsPlainLWE  = skElements2.GetElementAtIndex(i);
        for (size_t j = 0; j < skElementsPlain.GetLength(); j++) {
            if (skElementsFromPlain[j] == 0) {
                skElementsPlain[j] = 0;
            }
            else if (skElementsFromPlain[j] == 1) {
                skElementsPlain[j] = 1;
            }
            else
                skElementsPlain[j] = skElementsPlain.GetModulus() - 1;

            if (j >= lweskElements.GetLength()) {
                skElementsPlainLWE[j] = 0;
            }
            else {
                if (lweskElements[j] == 0) {
                    skElementsPlainLWE[j] = 0;
                }
                else if (lweskElements[j].ConvertToInt() == 1) {
                    skElementsPlainLWE[j] = 1;
                }
                else
                    skElementsPlainLWE[j] = skElementsPlain.GetModulus() - 1;
            }
        }
        skElements.SetElementAtIndex(i, skElementsPlain);
        skElements2.SetElementAtIndex(i, skElementsPlainLWE);
    }

    skElements.SetFormat(Format::EVALUATION);
    skElements2.SetFormat(Format::EVALUATION);

    auto ccCKKSto        = ckksSKto->GetCryptoContext();
    auto oldTranformedSK = ccCKKSto->KeyGen().secretKey;
    oldTranformedSK->SetPrivateElement(std::move(skElements));
    auto RLWELWEsk = ccCKKSto->KeyGen().secretKey;
    RLWELWEsk->SetPrivateElement(std::move(skElements2));

    return ccCKKSto->KeySwitchGen(oldTranformedSK, RLWELWEsk);
}

std::vector<std::vector<NativeInteger>> ExtractLWEpacked(const Ciphertext<DCRTPoly>& ct) {
    auto originalA{(ct->GetElements()[1]).GetElementAtIndex(0)};
    originalA.SetFormat(Format::COEFFICIENT);
    auto* ptrA = &originalA.GetValues()[0];
    auto originalB{(ct->GetElements()[0]).GetElementAtIndex(0)};
    originalB.SetFormat(Format::COEFFICIENT);
    auto* ptrB = &originalB.GetValues()[0];
    size_t N   = originalB.GetLength();
    std::vector<std::vector<NativeInteger>> extracted{std::vector<NativeInteger>(ptrB, ptrB + N),
                                                      std::vector<NativeInteger>(ptrA, ptrA + N)};
    return extracted;
}

std::shared_ptr<LWECiphertextImpl> ExtractLWECiphertext(const std::vector<std::vector<NativeInteger>>& aANDb,
                                                        NativeInteger modulus, uint32_t n, uint32_t index = 0) {
    auto N = aANDb[0].size();
    NativeVector a(n, modulus);
    NativeInteger b;

    for (size_t i = 0; i < n && i <= index; ++i) {
        a[i] = modulus - aANDb[1][index - i];
    }
    if (n > index) {
        for (size_t i = index + 1; i < n; ++i) {
            a[i] = aANDb[1][N + index - i];
        }
    }

    b           = aANDb[0][index];
    auto result = std::make_shared<LWECiphertextImpl>(std::move(a), std::move(b));
    return result;
}

//------------------------------------------------------------------------------
// Linear transformation methods.
// Currently mostly copied from ckksrns-fhe, because there an internal bootstrapping global structure is used.
// TODO: fix this.
//------------------------------------------------------------------------------

std::vector<ConstPlaintext> SWITCHCKKSRNS::EvalLTPrecomputeSwitch(
    const CryptoContextImpl<DCRTPoly>& cc, const std::vector<std::vector<std::complex<double>>>& A,
    const std::vector<std::vector<std::complex<double>>>& B, uint32_t dim1, uint32_t L, double scale = 1) const {
    uint32_t slots = A.size();
    uint32_t M     = cc.GetCyclotomicOrder();

    // Computing the baby-step bStep and the giant-step gStep
    uint32_t bStep = (dim1 == 0) ? getRatioBSGSLT(slots) : dim1;
    uint32_t gStep = ceil(static_cast<double>(slots) / bStep);

    const auto cryptoParamsCKKS = std::dynamic_pointer_cast<CryptoParametersCKKSRNS>(cc.GetCryptoParameters());

    ILDCRTParams<DCRTPoly::Integer> elementParams = *(cryptoParamsCKKS->GetElementParams());

    uint32_t towersToDrop = 0;
    if (L != 0) {
        towersToDrop = elementParams.GetParams().size() - L - 1;
        for (uint32_t i = 0; i < towersToDrop; i++)
            elementParams.PopLastParam();
    }

    const auto& paramsQ = elementParams.GetParams();
    const auto& paramsP = cryptoParamsCKKS->GetParamsP()->GetParams();

    size_t sizeQP = paramsQ.size() + paramsP.size();
    std::vector<NativeInteger> moduli;
    moduli.reserve(sizeQP);
    std::vector<NativeInteger> roots;
    roots.reserve(sizeQP);
    for (const auto& elem : paramsQ) {
        moduli.emplace_back(elem->GetModulus());
        roots.emplace_back(elem->GetRootOfUnity());
    }
    for (const auto& elem : paramsP) {
        moduli.emplace_back(elem->GetModulus());
        roots.emplace_back(elem->GetRootOfUnity());
    }

    auto elementParamsPtr = std::make_shared<ILDCRTParams<DCRTPoly::Integer>>(M, moduli, roots);

    std::vector<std::vector<std::complex<double>>> newA(slots);
    std::vector<ConstPlaintext> result(slots);

    //  A and B are concatenated horizontally
    for (uint32_t i = 0; i < A.size(); i++) {
        newA[i].reserve(A[i].size() + B[i].size());
        newA[i].insert(newA[i].end(), A[i].begin(), A[i].end());
        newA[i].insert(newA[i].end(), B[i].begin(), B[i].end());
    }

#pragma omp parallel for
    for (uint32_t j = 0; j < gStep; j++) {
        int32_t offset = -static_cast<int32_t>(bStep * j);
        for (uint32_t i = 0; i < bStep; i++) {
            if (bStep * j + i < slots) {
                // shifted diagonal is computed for rectangular map newA of dimension slots x 2*slots
                auto vec = ExtractShiftedDiagonal(newA, bStep * j + i);
                std::transform(vec.begin(), vec.end(), vec.begin(),
                               [&](const std::complex<double>& elem) { return elem * scale; });

                result[bStep * j + i] =
                    MakeAuxPlaintext(cc, elementParamsPtr, Rotate(Fill(vec, M / 4), offset), 1, towersToDrop, M / 4);
            }
        }
    }

    return result;
}

std::vector<ConstPlaintext> SWITCHCKKSRNS::EvalLTPrecomputeSwitch(
    const CryptoContextImpl<DCRTPoly>& cc, const std::vector<std::vector<std::complex<double>>>& A, uint32_t dim1,
    uint32_t L, double scale = 1) const {
    if (A[0].size() != A.size()) {
        OPENFHE_THROW("The matrix passed to EvalLTPrecomputeSwitch is not square");
    }

    uint32_t slots = A.size();

    uint32_t M     = cc.GetCyclotomicOrder();
    uint32_t bStep = (dim1 == 0) ? getRatioBSGSLT(slots) : dim1;
    uint32_t gStep = ceil(static_cast<double>(slots) / bStep);

    // Make sure the plaintext is created only with the necessary amount of moduli
    const auto cryptoParams = std::dynamic_pointer_cast<CryptoParametersCKKSRNS>(cc.GetCryptoParameters());

    ILDCRTParams<DCRTPoly::Integer> elementParams = *(cryptoParams->GetElementParams());

    uint32_t towersToDrop = 0;
    if (L != 0) {
        towersToDrop = elementParams.GetParams().size() - L - 1;
        for (uint32_t i = 0; i < towersToDrop; i++)
            elementParams.PopLastParam();
    }

    const auto& paramsQ = elementParams.GetParams();
    const auto& paramsP = cryptoParams->GetParamsP()->GetParams();

    size_t sizeQP = paramsQ.size() + paramsP.size();
    std::vector<NativeInteger> moduli;
    moduli.reserve(sizeQP);
    std::vector<NativeInteger> roots;
    roots.reserve(sizeQP);
    for (const auto& elem : paramsQ) {
        moduli.emplace_back(elem->GetModulus());
        roots.emplace_back(elem->GetRootOfUnity());
    }
    for (const auto& elem : paramsP) {
        moduli.emplace_back(elem->GetModulus());
        roots.emplace_back(elem->GetRootOfUnity());
    }

    auto elementParamsPtr = std::make_shared<ILDCRTParams<DCRTPoly::Integer>>(M, moduli, roots);

    std::vector<ConstPlaintext> result(slots);
#pragma omp parallel for
    for (uint32_t j = 0; j < gStep; j++) {
        int32_t offset = -static_cast<int32_t>(bStep * j);
        for (uint32_t i = 0; i < bStep; i++) {
            if (bStep * j + i < slots) {
                auto diag = ExtractShiftedDiagonal(A, bStep * j + i);
                std::transform(diag.begin(), diag.end(), diag.begin(),
                               [&](const std::complex<double>& elem) { return elem * scale; });
                result[bStep * j + i] =
                    MakeAuxPlaintext(cc, elementParamsPtr, Rotate(Fill(diag, M / 4), offset), 1, towersToDrop, M / 4);
            }
        }
    }

    return result;
}

std::vector<std::vector<std::complex<double>>> EvalLTRectPrecomputeSwitch(
    const std::vector<std::vector<std::complex<double>>>& A, uint32_t dim1, double scale) {
    if (!IsPowerOfTwo(A.size()) || !IsPowerOfTwo(A[0].size())) {
        OPENFHE_THROW("The matrix passed to EvalLTPrecompute is not padded up to powers of two");
    }
    uint32_t n     = std::min(A.size(), A[0].size());
    uint32_t bStep = (dim1 == 0) ? getRatioBSGSLT(n) : dim1;
    uint32_t gStep = ceil(static_cast<double>(n) / bStep);

    std::vector<std::vector<std::complex<double>>> diags(n);

    if (A.size() >= A[0].size()) {
        auto num_slices = A.size() / A[0].size();
        std::vector<std::vector<std::vector<std::complex<double>>>> A_slices(num_slices);
        for (size_t i = 0; i < num_slices; i++) {
            A_slices[i] = std::vector<std::vector<std::complex<double>>>(A.begin() + i * A[0].size(),
                                                                         A.begin() + (i + 1) * A[0].size());
        }
#pragma omp parallel for
        for (uint32_t j = 0; j < gStep; j++) {
            for (uint32_t i = 0; i < bStep; i++) {
                if (bStep * j + i < n) {
                    std::vector<std::complex<double>> diag;
                    diag.reserve(A.size() * num_slices);
                    for (uint32_t k = 0; k < num_slices; k++) {
                        auto tmp = ExtractShiftedDiagonal(A_slices[k], bStep * j + i);
                        diag.insert(diag.end(), std::make_move_iterator(tmp.begin()),
                                    std::make_move_iterator(tmp.end()));
                    }
                    std::transform(diag.begin(), diag.end(), diag.begin(),
                                   [&](const std::complex<double>& elem) { return elem * scale; });
                    diags[bStep * j + i] = std::move(diag);
                }
            }
        }
    }
    else {
#pragma omp parallel for
        for (uint32_t j = 0; j < gStep; j++) {
            for (uint32_t i = 0; i < bStep; i++) {
                if (bStep * j + i < n) {
                    std::vector<std::complex<double>> diag = ExtractShiftedDiagonal(A, bStep * j + i);
                    std::transform(diag.begin(), diag.end(), diag.begin(),
                                   [&](const std::complex<double>& elem) { return elem * scale; });
                    diags[bStep * j + i] = std::move(diag);
                }
            }
        }
    }
    return diags;
}

Ciphertext<DCRTPoly> SWITCHCKKSRNS::EvalLTWithPrecomputeSwitch(const CryptoContextImpl<DCRTPoly>& cc,
                                                               ConstCiphertext<DCRTPoly> ctxt,
                                                               const std::vector<ConstPlaintext>& A,
                                                               uint32_t dim1) const {
    uint32_t slots = A.size();

    // Computing the baby-step bStep and the giant-step gStep
    uint32_t bStep = dim1;
    uint32_t gStep = ceil(static_cast<double>(slots) / bStep);

    uint32_t M = cc.GetCyclotomicOrder();
    uint32_t N = cc.GetRingDimension();

    // Computes the NTTs for each CRT limb (for the hoisted automorphisms used later on)
    auto digits = cc.EvalFastRotationPrecompute(ctxt);

    std::vector<Ciphertext<DCRTPoly>> fastRotation(bStep - 1);

    // Hoisted automorphisms
#pragma omp parallel for
    for (uint32_t j = 1; j < bStep; j++) {
        fastRotation[j - 1] = cc.EvalFastRotationExt(ctxt, j, digits, true);
    }

    Ciphertext<DCRTPoly> result;
    DCRTPoly first;

    for (uint32_t j = 0; j < gStep; j++) {
        Ciphertext<DCRTPoly> inner = EvalMultExt(cc.KeySwitchExt(ctxt, true), A[bStep * j]);

        for (uint32_t i = 1; i < bStep; i++) {
            if (bStep * j + i < slots) {
                EvalAddExtInPlace(inner, EvalMultExt(fastRotation[i - 1], A[bStep * j + i]));
            }
        }

        if (j == 0) {
            first         = cc.KeySwitchDownFirstElement(inner);
            auto elements = inner->GetElements();
            elements[0].SetValuesToZero();
            inner->SetElements(elements);
            result = inner;
        }
        else {
            inner = cc.KeySwitchDown(inner);
            // Find the automorphism index that corresponds to the rotation index.
            usint autoIndex = FindAutomorphismIndex2nComplex(bStep * j, M);
            std::vector<usint> map(N);
            PrecomputeAutoMap(N, autoIndex, &map);
            DCRTPoly firstCurrent = inner->GetElements()[0].AutomorphismTransform(autoIndex, map);
            first += firstCurrent;

            auto innerDigits = cc.EvalFastRotationPrecompute(inner);
            EvalAddExtInPlace(result, cc.EvalFastRotationExt(inner, bStep * j, innerDigits, false));
        }
    }

    result        = cc.KeySwitchDown(result);
    auto elements = result->GetElements();
    elements[0] += first;
    result->SetElements(elements);

    return result;
}

Ciphertext<DCRTPoly> SWITCHCKKSRNS::EvalLTRectWithPrecomputeSwitch(
    const CryptoContextImpl<DCRTPoly>& cc, const std::vector<std::vector<std::complex<double>>>& A,
    ConstCiphertext<DCRTPoly> ct, bool wide, uint32_t dim1, uint32_t L) const {
    uint32_t n = std::min(A.size(), A[0].size());

    // Computing the baby-step bStep and the giant-step gStep
    uint32_t bStep = (dim1 == 0) ? getRatioBSGSLT(n) : dim1;
    uint32_t gStep = ceil(static_cast<double>(n) / bStep);

    uint32_t M = cc.GetCyclotomicOrder();
    uint32_t N = cc.GetRingDimension();

    // Computes the NTTs for each CRT limb (for the hoisted automorphisms used later on)
    auto digits = cc.EvalFastRotationPrecompute(ct);

    std::vector<Ciphertext<DCRTPoly>> fastRotation(bStep - 1);

    // Make sure the plaintext is created only with the necessary amount of moduli
    const auto cryptoParamsCKKS = std::dynamic_pointer_cast<CryptoParametersCKKSRNS>(ct->GetCryptoParameters());

    ILDCRTParams<DCRTPoly::Integer> elementParams = *(cryptoParamsCKKS->GetElementParams());
    uint32_t towersToDrop                         = 0;

    // For FLEXIBLEAUTOEXT we do not need extra modulus in auxiliary plaintexts
    if (L != 0) {
        towersToDrop = elementParams.GetParams().size() - L - 1;
        for (uint32_t i = 0; i < towersToDrop; i++)
            elementParams.PopLastParam();
    }
    if (cryptoParamsCKKS->GetScalingTechnique() == FLEXIBLEAUTOEXT) {
        towersToDrop += 1;
        elementParams.PopLastParam();
    }

    const auto& paramsQ = elementParams.GetParams();
    const auto& paramsP = cryptoParamsCKKS->GetParamsP()->GetParams();

    size_t sizeQP = paramsQ.size() + paramsP.size();
    std::vector<NativeInteger> moduli;
    moduli.reserve(sizeQP);
    std::vector<NativeInteger> roots;
    roots.reserve(sizeQP);
    for (const auto& elem : paramsQ) {
        moduli.emplace_back(elem->GetModulus());
        roots.emplace_back(elem->GetRootOfUnity());
    }
    for (const auto& elem : paramsP) {
        moduli.emplace_back(elem->GetModulus());
        roots.emplace_back(elem->GetRootOfUnity());
    }

    auto elementParamsPtr  = std::make_shared<ILDCRTParams<DCRTPoly::Integer>>(M, moduli, roots);
    auto elementParamsPtr2 = std::dynamic_pointer_cast<typename DCRTPoly::Params>(elementParamsPtr);

// Hoisted automorphisms
#pragma omp parallel for
    for (uint32_t j = 1; j < bStep; j++) {
        fastRotation[j - 1] = cc.EvalFastRotationExt(ct, j, digits, true);
    }

    Ciphertext<DCRTPoly> result;
    DCRTPoly first;

    for (uint32_t j = 0; j < gStep; j++) {
        int32_t offset = (j == 0) ? 0 : -static_cast<int32_t>(bStep * j);
        auto temp      = cc.MakeCKKSPackedPlaintext(Rotate(Fill(A[bStep * j], N / 2), offset), 1, towersToDrop,
                                                    elementParamsPtr2, N / 2);
        Ciphertext<DCRTPoly> inner = EvalMultExt(cc.KeySwitchExt(ct, true), temp);

        for (uint32_t i = 1; i < bStep; i++) {
            if (bStep * j + i < n) {
                auto tempi = cc.MakeCKKSPackedPlaintext(Rotate(Fill(A[bStep * j + i], N / 2), offset), 1, towersToDrop,
                                                        elementParamsPtr2, N / 2);
                EvalAddExtInPlace(inner, EvalMultExt(fastRotation[i - 1], tempi));
            }
        }

        if (j == 0) {
            first         = cc.KeySwitchDownFirstElement(inner);
            auto elements = inner->GetElements();
            elements[0].SetValuesToZero();
            inner->SetElements(elements);
            result = inner;
        }
        else {
            inner = cc.KeySwitchDown(inner);
            // Find the automorphism index that corresponds to rotation index index.
            usint autoIndex = FindAutomorphismIndex2nComplex(bStep * j, M);
            std::vector<usint> map(N);
            PrecomputeAutoMap(N, autoIndex, &map);
            DCRTPoly firstCurrent = inner->GetElements()[0].AutomorphismTransform(autoIndex, map);
            first += firstCurrent;

            auto innerDigits = cc.EvalFastRotationPrecompute(inner);
            EvalAddExtInPlace(result, cc.EvalFastRotationExt(inner, bStep * j, innerDigits, false));
        }
    }
    result        = cc.KeySwitchDown(result);
    auto elements = result->GetElements();
    elements[0] += first;
    result->SetElements(elements);

    // A represents the diagonals, which lose the information whether the initial matrix is tall or wide
    if (wide) {
        uint32_t logl = lbcrypto::GetMSB(A[0].size() / A.size()) - 1;  // These are powers of two, so log(l) is integer
        std::vector<Ciphertext<DCRTPoly>> ctxt(logl + 1);
        ctxt[0] = result;
        for (size_t j = 1; j <= logl; ++j) {
            ctxt[j] = cc.EvalAdd(ctxt[j - 1], cc.EvalAtIndex(ctxt[j - 1], A.size() * (1 << (j - 1))));
        }
        result = ctxt[logl];
    }

    return result;
}

Ciphertext<DCRTPoly> SWITCHCKKSRNS::EvalSlotsToCoeffsSwitch(const CryptoContextImpl<DCRTPoly>& cc,
                                                            ConstCiphertext<DCRTPoly> ctxt) const {
    uint32_t slots = m_numSlotsCKKS;
    uint32_t m     = 4 * slots;
    uint32_t M     = cc.GetCyclotomicOrder();
    bool isSparse  = (M != m) ? true : false;

    auto ctxtToDecode = ctxt->Clone();

    uint32_t numTowersToKeep = 2;
    const auto cryptoParams  = std::dynamic_pointer_cast<CryptoParametersCKKSRNS>(cc.GetCryptoParameters());
    if (cryptoParams->GetScalingTechnique() == ScalingTechnique::FLEXIBLEAUTO ||
        cryptoParams->GetScalingTechnique() == FLEXIBLEAUTOEXT) {
        ctxtToDecode = cc.Compress(ctxtToDecode, numTowersToKeep + 1);

        double targetSF =
            cryptoParams->GetScalingFactorReal(cryptoParams->GetElementParams()->GetParams().size() - numTowersToKeep);
        double sourceSF    = ctxtToDecode->GetScalingFactor();
        uint32_t numTowers = ctxtToDecode->GetElements()[0].GetNumOfElements();
        double modToDrop = cryptoParams->GetElementParams()->GetParams()[numTowers - 1]->GetModulus().ConvertToDouble();
        double adjustmentFactor = (targetSF / sourceSF) * (modToDrop / sourceSF);

        ctxtToDecode = cc.EvalMult(ctxtToDecode, adjustmentFactor);
        cc.GetScheme()->ModReduceInternalInPlace(ctxtToDecode, 1);
        ctxtToDecode->SetScalingFactor(targetSF);
    }
    else {
        ctxtToDecode = cc.Compress(ctxtToDecode, numTowersToKeep);
    }

    Ciphertext<DCRTPoly> ctxtDecoded;

    if (slots != m_numSlotsCKKS || m_U0Pre.size() == 0) {
        std::string errorMsg(std::string("Precomputations for ") + std::to_string(slots) +
                             std::string(" slots were not generated") +
                             std::string(" Need to call EvalCKKSToFHEWPrecompute to proceed"));
        OPENFHE_THROW(errorMsg);
    }

    if (!isSparse) {  // fully packed
        // ctxtToDecode = cc.EvalAdd(ctxtToDecode, cc.GetScheme()->MultByMonomial(ctxtToDecode, M / 4));
        ctxtDecoded = EvalLTWithPrecomputeSwitch(cc, ctxtToDecode, m_U0Pre, m_dim1CF);
    }
    else {  // sparsely packed
        ctxtDecoded = EvalLTWithPrecomputeSwitch(cc, ctxtToDecode, m_U0Pre, m_dim1CF);
        cc.EvalAddInPlace(ctxtDecoded, cc.EvalAtIndex(ctxtDecoded, slots));
    }

    return ctxtDecoded;
}

Ciphertext<DCRTPoly> SWITCHCKKSRNS::EvalPartialHomDecryption(const CryptoContextImpl<DCRTPoly>& cc,
                                                             const std::vector<std::vector<std::complex<double>>>& A,
                                                             ConstCiphertext<DCRTPoly> ct, uint32_t dim1, double scale,
                                                             uint32_t L) const {
    // Currently, by design, the # rows (# LWE ciphertexts to switch) is a power of two.
    // Ensure that # cols (LWE lattice parameter n) is padded up to a power of two
    std::vector<std::vector<std::complex<double>>> Acopy(A);
    uint32_t cols_po2 = 1 << static_cast<uint32_t>(std::ceil(std::log2(A[0].size())));

    if (cols_po2 > A[0].size()) {
        for (size_t i = 0; i < A.size(); ++i) {
            Acopy[i].resize(cols_po2);
        }
    }

    auto Apre = EvalLTRectPrecomputeSwitch(Acopy, dim1, scale);
    auto res  = EvalLTRectWithPrecomputeSwitch(cc, Apre, ct, (Acopy.size() < A[0].size()), dim1,
                                               L);  // The result is repeated every Acopy.size() slots

    return res;
}

//------------------------------------------------------------------------------
// Scheme switching Wrapper
//------------------------------------------------------------------------------
LWEPrivateKey SWITCHCKKSRNS::EvalCKKStoFHEWSetup(const SchSwchParams& params) {
    if (params.GetSecurityLevelFHEW() != TOY && params.GetSecurityLevelFHEW() != STD128)
        OPENFHE_THROW("Only STD128 or TOY are currently supported.");

    uint32_t ringDim = params.GetRingDimension();
    if (params.GetNumSlotsCKKS() == 0 || params.GetNumSlotsCKKS() == (ringDim / 2))  // fully-packed
        m_numSlotsCKKS = ringDim / 2;
    else  // sparsely-packed
        m_numSlotsCKKS = params.GetNumSlotsCKKS();

    m_modulus_CKKS_initial = params.GetInitialCKKSModulus();
    // Modulus to switch to in order to have secure RLWE samples with ring dimension n.
    // We can select any Qswitch less than 27 bits corresponding to 128 bits of security for lattice parameter n=1024 < 1305
    // according to https://homomorphicencryption.org/wp-content/uploads/2018/11/HomomorphicEncryptionStandardv1.1.pdf
    // or any Qswitch for TOY security.
    // Ensure that Qswitch is larger than Q_FHEW and smaller than Q_CKKS.
    if (params.GetCtxtModSizeFHEWIntermedSwch() <= params.GetCtxtModSizeFHEWLargePrec() ||
        params.GetCtxtModSizeFHEWIntermedSwch() > GetMSB(m_modulus_CKKS_initial.ConvertToInt()) - 1) {
        OPENFHE_THROW("Qswitch should be larger than QFHEW and smaller than QCKKS.");
    }
    // Intermediate cryptocontext
    CCParams<CryptoContextCKKSRNS> parameters;
    parameters.SetMultiplicativeDepth(0);
    parameters.SetFirstModSize(params.GetCtxtModSizeFHEWIntermedSwch());
    parameters.SetScalingModSize(params.GetScalingModSize());
    // This doesn't need this to be the same scaling technique as the outer cryptocontext, since we only do a key switch
    parameters.SetScalingTechnique(FIXEDMANUAL);
    parameters.SetSecurityLevel(params.GetSecurityLevelCKKS());
    parameters.SetRingDim(ringDim);
    parameters.SetBatchSize(params.GetBatchSize());

    m_ccKS = GenCryptoContext(parameters);

    // Enable the features that you wish to use
    m_ccKS->Enable(PKE);
    m_ccKS->Enable(KEYSWITCH);

    // Get the ciphertext modulus
    const auto cryptoParams = std::dynamic_pointer_cast<CryptoParametersCKKSRNS>(m_ccKS->GetCryptoParameters());
    m_modulus_CKKS_from     = cryptoParams->GetElementParams()->GetParams()[0]->GetModulus();

    m_ccLWE = std::make_shared<BinFHEContext>();
    m_ccLWE->BinFHEContext::GenerateBinFHEContext(
        params.GetSecurityLevelFHEW(), params.GetArbitraryFunctionEvaluation(), params.GetCtxtModSizeFHEWLargePrec(), 0,
        GINX, params.GetUseDynamicModeFHEW());

    // For arbitrary functions, the LWE ciphertext needs to be at most the ring dimension in FHEW bootstrapping
    m_modulus_LWE = (!params.GetArbitraryFunctionEvaluation()) ?
                        1 << params.GetCtxtModSizeFHEWLargePrec() :
                        m_ccLWE->GetParams()->GetLWEParams()->Getq().ConvertToInt();

    // LWE private key
    LWEPrivateKey lwesk = m_ccLWE->KeyGen();

    // The baby-step and number of levels for the linear transformation associated to the homomorphic decoding
    m_dim1CF = (params.GetBStepLTrCKKStoFHEW() == 0) ? getRatioBSGSLT(params.GetNumSlotsCKKS()) :
                                                       params.GetBStepLTrCKKStoFHEW();
    m_LCF    = params.GetLevelLTrCKKStoFHEW();

    return lwesk;
}

std::shared_ptr<std::map<usint, EvalKey<DCRTPoly>>> SWITCHCKKSRNS::EvalCKKStoFHEWKeyGen(
    const KeyPair<DCRTPoly>& keyPair, ConstLWEPrivateKey& lwesk) {
    auto privateKey = keyPair.secretKey;
    auto publicKey  = keyPair.publicKey;

    const auto cryptoParams = std::dynamic_pointer_cast<CryptoParametersCKKSRNS>(privateKey->GetCryptoParameters());

    if (cryptoParams->GetKeySwitchTechnique() != HYBRID)
        OPENFHE_THROW("CKKS to FHEW scheme switching is only supported for the Hybrid key switching method.");
#if NATIVEINT == 128 && !defined(__EMSCRIPTEN__)
    if (cryptoParams->GetScalingTechnique() == FLEXIBLEAUTO || cryptoParams->GetScalingTechnique() == FLEXIBLEAUTOEXT)
        OPENFHE_THROW("128-bit CKKS to FHEW scheme switching is supported for FIXEDMANUAL and FIXEDAUTO methods only.");
#endif

    auto ccCKKS = privateKey->GetCryptoContext();

    // Intermediate cryptocontext for CKKS to FHEW
    auto keys2 = m_ccKS->KeyGen();

    Plaintext ptxtZeroKS = m_ccKS->MakeCKKSPackedPlaintext(std::vector<double>{0.0});
    m_ctxtKS             = m_ccKS->Encrypt(keys2.publicKey, ptxtZeroKS);

    // Compute switching key between RLWE and LWE via the intermediate cryptocontext, keep it in RLWE form
    m_CKKStoFHEWswk = switchingKeyGenRLWEcc(keys2.secretKey, privateKey, lwesk);

    // Compute automorphism keys
    uint32_t M     = ccCKKS->GetCyclotomicOrder();
    uint32_t slots = m_numSlotsCKKS;

    // Compute indices for rotations for slotToCoeff transform
    std::vector<int32_t> indexRotationS2C = FindLTRotationIndicesSwitch(m_dim1CF, M, slots);
    indexRotationS2C.emplace_back(static_cast<int32_t>(slots));

    // Remove possible duplicates and zero
    sort(indexRotationS2C.begin(), indexRotationS2C.end());
    indexRotationS2C.erase(unique(indexRotationS2C.begin(), indexRotationS2C.end()), indexRotationS2C.end());
    indexRotationS2C.erase(std::remove(indexRotationS2C.begin(), indexRotationS2C.end(), 0), indexRotationS2C.end());

    auto algo = ccCKKS->GetScheme();

    // Compute multiplication key
    algo->EvalMultKeyGen(privateKey);

    auto evalKeys = algo->EvalAtIndexKeyGen(publicKey, privateKey, indexRotationS2C);

    // Compute conjugation key
    auto conjKey       = ConjugateKeyGen(privateKey);
    (*evalKeys)[M - 1] = conjKey;

    return evalKeys;
}

void SWITCHCKKSRNS::EvalCKKStoFHEWPrecompute(const CryptoContextImpl<DCRTPoly>& cc, double scale) {
    uint32_t M     = cc.GetCyclotomicOrder();
    uint32_t slots = m_numSlotsCKKS;

    uint32_t m    = 4 * m_numSlotsCKKS;
    bool isSparse = (M != m) ? true : false;

    // Computes indices for all primitive roots of unity
    std::vector<uint32_t> rotGroup(slots);
    uint32_t fivePows = 1;
    for (uint32_t i = 0; i < slots; ++i) {
        rotGroup[i] = fivePows;
        fivePows *= 5;
        fivePows %= m;
    }
    // Computes all powers of a primitive root of unity exp(2*M_PI/m)
    std::vector<std::complex<double>> ksiPows(m + 1);
    for (uint32_t j = 0; j < m; ++j) {
        double angle = 2.0 * M_PI * j / m;
        ksiPows[j].real(cos(angle));
        ksiPows[j].imag(sin(angle));
    }
    ksiPows[m] = ksiPows[0];

    // Matrices for decoding
    std::vector<std::vector<std::complex<double>>> U0(slots, std::vector<std::complex<double>>(slots));
    std::vector<std::vector<std::complex<double>>> U1(slots, std::vector<std::complex<double>>(slots));

    for (size_t i = 0; i < slots; i++) {
        for (size_t j = 0; j < slots; j++) {
            U0[i][j] = ksiPows[(j * rotGroup[i]) % m];
            U1[i][j] = std::complex<double>(0, 1) * U0[i][j];
        }
    }

    // Obtain the right scaling for encoded messages in FHEW coming from encoded messages in CKKS
    const auto cryptoParams = std::dynamic_pointer_cast<CryptoParametersCKKSRNS>(cc.GetCryptoParameters());
    double scFactor = cryptoParams->GetScalingFactorReal(cryptoParams->GetElementParams()->GetParams().size() - 1);
    scale *= m_modulus_CKKS_initial.ConvertToDouble() / scFactor;

    if (!isSparse) {  // fully packed
        m_U0Pre = EvalLTPrecomputeSwitch(cc, U0, m_dim1CF, m_LCF, scale);
    }
    else {  // sparsely packed
        m_U0Pre = EvalLTPrecomputeSwitch(cc, U0, U1, m_dim1CF, m_LCF, scale);
    }
}

std::vector<std::shared_ptr<LWECiphertextImpl>> SWITCHCKKSRNS::EvalCKKStoFHEW(ConstCiphertext<DCRTPoly> ciphertext,
                                                                              uint32_t numCtxts) {
    auto ccCKKS    = ciphertext->GetCryptoContext();
    uint32_t slots = m_numSlotsCKKS;

    if (numCtxts == 0 || numCtxts > slots) {
        numCtxts = slots;
    }

    // Step 1. Homomorphic decoding
    auto ctxtDecoded = EvalSlotsToCoeffsSwitch(*ccCKKS, ciphertext);
    ccCKKS->GetScheme()->ModReduceInternalInPlace(ctxtDecoded, 1);

    const auto cryptoParams = std::dynamic_pointer_cast<CryptoParametersCKKSRNS>(ccCKKS->GetCryptoParameters());

    // Step 2. Modulus switch to Q', such that CKKS is secure for (Q',n)
    auto ctxtKS = m_ctxtKS->Clone();
    ModSwitch(ctxtDecoded, ctxtKS, m_modulus_CKKS_from);

    // Step 3: Key switch from the CKKS key with the new modulus Q' to the RLWE version of the FHEW key with the new modulus Q'
    auto ccKS       = ctxtKS->GetCryptoContext();  // Use this instead of m_ccKS to work with serialization
    auto ctSwitched = ccKS->KeySwitch(ctxtKS, m_CKKStoFHEWswk);

    // Step 4. Extract LWE ciphertexts with the modulus Q'
    uint32_t n = m_ccLWE->GetParams()->GetLWEParams()->Getn();  // lattice parameter for additive LWE
    std::vector<std::shared_ptr<LWECiphertextImpl>> LWEciphertexts(numCtxts);
    auto AandB = ExtractLWEpacked(ctSwitched);

    uint32_t gap = ccKS->GetRingDimension() / (2 * slots);

    for (uint32_t i = 0, idx = 0; i < numCtxts; ++i, idx += gap) {
        LWEciphertexts[i] = ExtractLWECiphertext(AandB, m_modulus_CKKS_from, n, idx);
    }

    // Step 5. Modulus switch to q in FHEW

    // Compute the necessary factor to obtaine the message Q'/pLWE
    if (m_modulus_LWE != m_modulus_CKKS_from) {
#pragma omp parallel for
        for (uint32_t i = 0; i < numCtxts; i++) {
            auto original_a = LWEciphertexts[i]->GetA();
            auto original_b = LWEciphertexts[i]->GetB();
            // multiply by Q_LWE/Q' and round to Q_LWE
            NativeVector a_round(n, m_modulus_LWE);
            for (uint32_t j = 0; j < n; ++j) {
                a_round[j] = RoundqQAlter(original_a[j], m_modulus_LWE, m_modulus_CKKS_from);
            }
            NativeInteger b_round = RoundqQAlter(original_b, m_modulus_LWE, m_modulus_CKKS_from);
            LWEciphertexts[i]     = std::make_shared<LWECiphertextImpl>(std::move(a_round), std::move(b_round));
        }
    }

    return LWEciphertexts;
}

//------------------------------------------------------------------------------
// Scheme switching Wrapper
//------------------------------------------------------------------------------
void SWITCHCKKSRNS::EvalFHEWtoCKKSSetup(const CryptoContextImpl<DCRTPoly>& ccCKKS,
                                        const std::shared_ptr<BinFHEContext>& ccLWE, uint32_t numSlotsCKKS,
                                        uint32_t logQ) {
    m_ccLWE = ccLWE;

    if (m_ccLWE->GetParams()->GetLWEParams()->Getn() * 2 > ccCKKS.GetRingDimension())
        OPENFHE_THROW("The lattice parameter in LWE cannot be larger than half the RLWE ring dimension.");

    if (numSlotsCKKS == 0) {
        if (ccCKKS.GetEncodingParams()->GetBatchSize() != 0)
            m_numSlotsCKKS = ccCKKS.GetEncodingParams()->GetBatchSize();
        else
            m_numSlotsCKKS = ccCKKS.GetRingDimension() / 2;
    }
    else {
        m_numSlotsCKKS = numSlotsCKKS;
    }

    m_modulus_LWE = (logQ != 0) ? 1 << logQ : m_ccLWE->GetParams()->GetLWEParams()->Getq().ConvertToInt();
}

std::shared_ptr<std::map<usint, EvalKey<DCRTPoly>>> SWITCHCKKSRNS::EvalFHEWtoCKKSKeyGen(
    const KeyPair<DCRTPoly>& keyPair, ConstLWEPrivateKey& lwesk, uint32_t numSlots, uint32_t numCtxts, uint32_t dim1,
    uint32_t L) {
    auto privateKey = keyPair.secretKey;
    auto publicKey  = keyPair.publicKey;

    const auto cryptoParams = std::dynamic_pointer_cast<CryptoParametersCKKSRNS>(privateKey->GetCryptoParameters());
    auto ccCKKS             = privateKey->GetCryptoContext();

    uint32_t n       = lwesk->GetElement().GetLength();
    uint32_t ringDim = ccCKKS->GetRingDimension();

    // Generate FHEW to CKKS switching key, i.e., CKKS encryption of FHEW secret key. Pad up to the closest power of two
    uint32_t n_po2     = 1 << static_cast<uint32_t>(std::ceil(std::log2(n)));
    auto skLWEElements = lwesk->GetElement();
    std::vector<std::complex<double>> skLWEDouble(n_po2);
    for (uint32_t i = 0; i < n; i++) {
        auto tmp = skLWEElements[i].ConvertToDouble();
        if (tmp == lwesk->GetModulus().ConvertToInt() - 1)
            tmp = -1;
        skLWEDouble[i] = std::complex<double>(tmp, 0);
    }

    // Check encoding and specify the number of slots, otherwise, if batchsize is set and is smaller, it will throw an error.
    Plaintext skLWEPlainswk;
    if (cryptoParams->GetScalingTechnique() == FLEXIBLEAUTOEXT)
        skLWEPlainswk = ccCKKS->MakeCKKSPackedPlaintext(Fill(skLWEDouble, ringDim / 2), 1, BASE_NUM_LEVELS_TO_DROP,
                                                        nullptr, ringDim / 2);
    else
        skLWEPlainswk = ccCKKS->MakeCKKSPackedPlaintext(Fill(skLWEDouble, ringDim / 2), 1, 0, nullptr, ringDim / 2);

    m_FHEWtoCKKSswk = ccCKKS->Encrypt(publicKey, skLWEPlainswk);

    // Compute automorphism keys for CKKS for baby-step giant-step
    if (numCtxts == 0) {
        numCtxts = m_numSlotsCKKS;  // If no value is specified, default to the column size of the linear transformation
    }
    uint32_t M = ccCKKS->GetCyclotomicOrder();
    if (dim1 == 0)
        dim1 = getRatioBSGSLT(numCtxts);
    m_dim1FC = dim1;
    m_LFC    = L;

    // Compute indices for rotations for homomorphic decryption in CKKS
    std::vector<int32_t> indexRotationHomDec = FindLTRotationIndicesSwitch(dim1, M, numCtxts);

    // If the linear transform is wide instead of tall, we need extra rotations
    if (numCtxts < n_po2) {
        uint32_t logl = lbcrypto::GetMSB(n_po2 / numCtxts) - 1;  // These are powers of two, so log(l) is integer
        indexRotationHomDec.reserve(indexRotationHomDec.size() + logl);
        for (size_t j = 1; j <= logl; ++j) {
            indexRotationHomDec.emplace_back(numCtxts * (1 << (j - 1)));
        }
    }

    uint32_t slots = (numSlots == 0) ? m_numSlotsCKKS : numSlots;
    // Compute indices for rotations to bring back the final CKKS ciphertext encoding to slots
    if (ringDim > 2 * slots) {  // if the encoding is full, this does not execute
        indexRotationHomDec.reserve(indexRotationHomDec.size() + GetMSB(ringDim) - 2);
        for (uint32_t j = 1; j < ringDim / (2 * slots); j <<= 1) {
            indexRotationHomDec.emplace_back(j * slots);
        }
    }

    // Remove possible duplicates and zero
    sort(indexRotationHomDec.begin(), indexRotationHomDec.end());
    indexRotationHomDec.erase(unique(indexRotationHomDec.begin(), indexRotationHomDec.end()),
                              indexRotationHomDec.end());
    indexRotationHomDec.erase(std::remove(indexRotationHomDec.begin(), indexRotationHomDec.end(), 0),
                              indexRotationHomDec.end());

    auto algo     = ccCKKS->GetScheme();
    auto evalKeys = algo->EvalAtIndexKeyGen(publicKey, privateKey, indexRotationHomDec);

    // Compute multiplication key
    ccCKKS->EvalMultKeyGen(privateKey);

    return evalKeys;
}

Ciphertext<DCRTPoly> SWITCHCKKSRNS::EvalFHEWtoCKKS(std::vector<std::shared_ptr<LWECiphertextImpl>>& LWECiphertexts,
                                                   uint32_t numCtxts, uint32_t numSlots, uint32_t p, double pmin,
                                                   double pmax, uint32_t dim1, bool clean, bool highPrec) const {
    // High precision with arcsin
    if (!LWECiphertexts.size())
        OPENFHE_THROW("Empty input FHEW ciphertext vector");

    if (highPrec && clean) {
        std::string errorMsg(std::string("It is not recommended to set both clean and highPrec"));
        OPENFHE_THROW(errorMsg);
    }

    // This is the number of CKKS slots to use in encoding
    const uint32_t slots = (numSlots == 0) ? m_numSlotsCKKS : numSlots;

    uint32_t numLWECtxts = LWECiphertexts.size();
    uint32_t numValues   = (numCtxts == 0) ? numLWECtxts : std::min(numCtxts, numLWECtxts);
    numValues = std::min(numValues, slots);  // This is the number of LWE ciphertexts to pack into the CKKS ciphertext

    uint32_t n = LWECiphertexts[0]->GetA().GetLength();

    auto ccCKKS                 = m_FHEWtoCKKSswk->GetCryptoContext();
    const auto cryptoParamsCKKS = std::dynamic_pointer_cast<CryptoParametersCKKSRNS>(ccCKKS->GetCryptoParameters());

    uint32_t m    = 4 * slots;
    uint32_t M    = ccCKKS->GetCyclotomicOrder();
    uint32_t N    = ccCKKS->GetRingDimension();
    bool isSparse = (M != m) ? true : false;

    double K = 0.0;
    std::vector<double> coefficientsFHEW;  // EvalFHEWtoCKKS assumes lattice parameter n is at most 2048.
    if (n == 32) {
        K = 16.0;
        if (highPrec) {
            coefficientsFHEW.assign(g_coefficients_sin_16);
        }
        else {
            coefficientsFHEW.assign(g_coefficients_sin2pi_16);
        }
    }
    else {
        K = 128.0;  // Failure probability of 2^{-49}
        if (p <= 4) {
            // If the output messages are bits, we could use a lower degree polynomial
            coefficientsFHEW.assign(g_coefficientsFHEW128_8);
        }
        else {
            if (highPrec) {
                coefficientsFHEW.assign(g_coefficients_sin_128_9);
            }
            else {
                coefficientsFHEW.assign(g_coefficients_sin2pi_128_9);
            }
        }
    }

    // Step 1. Form matrix A and vector b from the LWE ciphertexts, but only extract the first necessary number of them
    std::vector<std::vector<std::complex<double>>> A(numValues);

    // To have the same encoding as A*s, create b with the appropriate number of elements
    const uint32_t b_size = ((numValues % n) != 0) ? (numValues + n - (numValues % n)) : numValues;
    std::vector<std::complex<double>> b(b_size);

    // Combine the scale with the division by K to consume fewer levels, but careful since the value might be too small
    const double prescale = (1.0 / LWECiphertexts[0]->GetModulus().ConvertToDouble()) / K;

#pragma omp parallel for
    for (uint32_t i = 0; i < numValues; i++) {
        auto a = LWECiphertexts[i]->GetA();
        A[i]   = std::vector<std::complex<double>>(a.GetLength());
        for (uint32_t j = 0; j < a.GetLength(); j++) {
            A[i][j] = std::complex<double>(a[j].ConvertToDouble(), 0);
        }
        b[i] = std::complex<double>(prescale * LWECiphertexts[i]->GetB().ConvertToDouble(), 0);
    }

    // Step 2. Perform the homomorphic linear transformation of A*skLWE
    if (dim1 == 0) {
        dim1 = m_dim1FC;
    }
    Ciphertext<DCRTPoly> AdotS = EvalPartialHomDecryption(*ccCKKS, A, m_FHEWtoCKKSswk, dim1, prescale, 0);

    // Step 3. Get the ciphertext of B - A*s
    Plaintext BPlain = ccCKKS->MakeCKKSPackedPlaintext(b, AdotS->GetNoiseScaleDeg(), AdotS->GetLevel(), nullptr, N / 2);

    auto BminusAdotS = ccCKKS->EvalAdd(ccCKKS->EvalNegate(AdotS), BPlain);

    if (cryptoParamsCKKS->GetScalingTechnique() == FIXEDMANUAL) {
        ccCKKS->ModReduceInPlace(BminusAdotS);
    }
    else {
        if (BminusAdotS->GetNoiseScaleDeg() == 2)
            ccCKKS->GetScheme()->ModReduceInternalInPlace(BminusAdotS, BASE_NUM_LEVELS_TO_DROP);
    }

    // Step 4. Do the modulus reduction: homomorphically evaluate modular function. We do it by using sine approximation.
    // auto BminusAdotS2 = BminusAdotS;  // Instead of zeroing out slots which are not of interest as done above

    double a_cheby = -1;
    double b_cheby = 1;  // The division by K was performed before

    // double a_cheby = -K; double b_cheby = K; // Alternatively, do this separately to not lose precision when scaling with everything at once
    auto BminusAdotS3 = ccCKKS->EvalChebyshevSeries(BminusAdotS, coefficientsFHEW, a_cheby, b_cheby);

    if (cryptoParamsCKKS->GetScalingTechnique() != FIXEDMANUAL) {
        ccCKKS->GetScheme()->ModReduceInternalInPlace(BminusAdotS3, BASE_NUM_LEVELS_TO_DROP);
    }

    enum { BT_ITER = 3 };
    for (int32_t j = 1; j < BT_ITER + 1; j++) {
        ccCKKS->EvalSquareInPlace(BminusAdotS3);  // BminusAdotS3 = ccCKKS->EvalMult(BminusAdotS3, BminusAdotS3);
        ccCKKS->EvalAddInPlace(BminusAdotS3, BminusAdotS3);
        double scalar = 1.0;
        if (!highPrec) {
            scalar = 1.0 / std::pow((2.0 * Pi), std::pow(2.0, j - BT_ITER));
        }
        ccCKKS->EvalSubInPlace(BminusAdotS3, scalar);
        if (cryptoParamsCKKS->GetScalingTechnique() == FIXEDMANUAL) {
            ccCKKS->ModReduceInPlace(BminusAdotS3);
        }
        else {
            ccCKKS->GetScheme()->ModReduceInternalInPlace(BminusAdotS3, BASE_NUM_LEVELS_TO_DROP);
        }
    }

    // Apply also the arcsin approximation if larger precision (for messages up to p/4) is desired
    if (highPrec && (p > 4)) {
        coefficientsFHEW.assign(g_coefficients_asin128_6);
        BminusAdotS3 = ccCKKS->EvalChebyshevSeries(BminusAdotS3, coefficientsFHEW, a_cheby, b_cheby);
    }

    /* For p <= 4 and when we only encrypt bits, we don't need sin(2pi*x)/2pi to approximate x,
         * we can directly use sin(0) for 0 and sin(pi/2) for 1.
         * Here pmax is actually the plaintext modulus, not the maximum value of the messages that we
         * consider. For plaintext modulus > 4, even if we only care about encrypting bits, 2pi is not
         * the correct post-scaling factor.
         * Moreover, we have to account for the different encoding the end ciphertext should have.
         */
    double postScale = (p >= 1 && p <= 4) ? (static_cast<double>(2) * Pi) : static_cast<double>(p);
    double postBias  = 0.0;
    if (pmin != 0) {
        postScale *= (pmax - pmin) / 4.0;
        postBias = (pmax - pmin) / 4.0;
    }

    // numValues are set; the rest of values up to N/2 are made zero when creating the plaintext
    std::vector<std::complex<double>> postScaleVec(numValues, std::complex<double>(postScale, 0));
    std::vector<std::complex<double>> postBiasVec(numValues, std::complex<double>(postBias, 0));

    ILDCRTParams<DCRTPoly::Integer> elementParams = *(cryptoParamsCKKS->GetElementParams());

    uint32_t towersToDrop = BminusAdotS3->GetLevel() + BminusAdotS3->GetNoiseScaleDeg() - 1;
    for (uint32_t i = 0; i < towersToDrop; i++) {
        elementParams.PopLastParam();
    }

    // Use full packing here to clear up the junk in the slots after numValues
    auto postScalePlain = ccCKKS->MakeCKKSPackedPlaintext(postScaleVec, 1, towersToDrop, nullptr, N / 2);
    auto BminusAdotSres = ccCKKS->EvalMult(BminusAdotS3, postScalePlain);

    // Add the plaintext for bias at the correct level and depth
    auto postBiasPlain = ccCKKS->MakeCKKSPackedPlaintext(postBiasVec, BminusAdotSres->GetNoiseScaleDeg(),
                                                         BminusAdotSres->GetLevel(), nullptr, N / 2);

    ccCKKS->EvalAddInPlace(BminusAdotSres, postBiasPlain);

    // Additional cleaning for binary messages
    if (clean) {
        auto square = ccCKKS->EvalSquare(BminusAdotSres);
        auto cube   = ccCKKS->EvalMult(square, BminusAdotSres);
        ccCKKS->EvalAddInPlace(square, ccCKKS->EvalAdd(square, square));
        ccCKKS->EvalAddInPlace(cube, cube);
        BminusAdotSres = ccCKKS->EvalAdd(ccCKKS->EvalNegate(cube), square);

        if (cryptoParamsCKKS->GetScalingTechnique() == FIXEDMANUAL) {
            ccCKKS->ModReduceInPlace(BminusAdotSres);
        }
        else {
            ccCKKS->GetScheme()->ModReduceInternalInPlace(BminusAdotSres, BASE_NUM_LEVELS_TO_DROP);
        }
    }

    // Go back to the sparse encoding if needed
    if (isSparse) {
        for (uint32_t j = 1; j < N / (2 * slots); j <<= 1) {
            auto temp = ccCKKS->EvalAtIndex(BminusAdotSres, j * slots);
            ccCKKS->EvalAddInPlace(BminusAdotSres, temp);
        }
        BminusAdotSres->SetSlots(slots);
    }

    if (cryptoParamsCKKS->GetScalingTechnique() == FIXEDMANUAL) {
        ccCKKS->ModReduceInPlace(BminusAdotSres);
    }

    return BminusAdotSres;

    //     // High precision with sine series of the 4th order
    //     if (!LWECiphertexts.size())
    //         OPENFHE_THROW("Empty input FHEW ciphertext vector");

    //     if (highPrec && clean) {
    //         std::string errorMsg(std::string("It is not recommended to set both clean and highPrec"));
    //         OPENFHE_THROW(errorMsg);
    //     }

    //     // This is the number of CKKS slots to use in eg_coefficients_sin2pi_128_9ncoding
    //     const uint32_t slots = (numSlots == 0) ? m_numSlotsCKKS : numSlots;

    //     uint32_t numLWECtxts = LWECiphertexts.size();
    //     uint32_t numValues   = (numCtxts == 0) ? numLWECtxts : std::min(numCtxts, numLWECtxts);
    //     numValues = std::min(numValues, slots);  // This is the number of LWE ciphertexts to pack into the CKKS ciphertext

    //     uint32_t n = LWECiphertexts[0]->GetA().GetLength();

    //     auto ccCKKS                 = m_FHEWtoCKKSswk->GetCryptoContext();
    //     const auto cryptoParamsCKKS = std::dynamic_pointer_cast<CryptoParametersCKKSRNS>(ccCKKS->GetCryptoParameters());

    //     uint32_t m    = 4 * slots;
    //     uint32_t M    = ccCKKS->GetCyclotomicOrder();
    //     uint32_t N    = ccCKKS->GetRingDimension();
    //     bool isSparse = (M != m) ? true : false;

    //     double K = 0.0;
    //     std::vector<double> coefficientsFHEW;  // EvalFHEWtoCKKS assumes lattice parameter n is at most 2048.
    //     if (n == 32) {
    //         K = 16.0;
    //         if (highPrec) {
    //             coefficientsFHEW.assign(g_coefficients_sin2pi_4th_16);
    //         }
    //         else {
    //             coefficientsFHEW.assign(g_coefficients_sin2pi_16);
    //         }
    //     }
    //     else {
    //         K = 128.0;  // Failure probability of 2^{-49}
    //         if (p <= 4) {
    //             // If the output messages are bits, we could use a lower degree polynomial
    //             coefficientsFHEW.assign(g_coefficientsFHEW128_8);
    //         }
    //         else {
    //             if (highPrec) {
    //                 coefficientsFHEW.assign(g_coefficients_sin2pi_4th_128);
    //             }
    //             else {
    //                 coefficientsFHEW.assign(g_coefficients_sin2pi_128_9);
    //             }
    //         }
    //     }

    //     // Step 1. Form matrix A and vector b from the LWE ciphertexts, but only extract the first necessary number of them
    //     std::vector<std::vector<std::complex<double>>> A(numValues);

    //     // To have the same encoding as A*s, create b with the appropriate number of elements
    //     const uint32_t b_size = ((numValues % n) != 0) ? (numValues + n - (numValues % n)) : numValues;
    //     std::vector<std::complex<double>> b(b_size);

    //     // Combine the scale with the division by K to consume fewer levels, but careful since the value might be too small
    //     const double prescale = (1.0 / LWECiphertexts[0]->GetModulus().ConvertToDouble()) / K;

    // #pragma omp parallel for
    //     for (uint32_t i = 0; i < numValues; i++) {
    //         auto a = LWECiphertexts[i]->GetA();
    //         A[i]   = std::vector<std::complex<double>>(a.GetLength());
    //         for (uint32_t j = 0; j < a.GetLength(); j++) {
    //             A[i][j] = std::complex<double>(a[j].ConvertToDouble(), 0);
    //         }
    //         b[i] = std::complex<double>(prescale * LWECiphertexts[i]->GetB().ConvertToDouble(), 0);
    //     }

    //     // Step 2. Perform the homomorphic linear transformation of A*skLWE
    //     if (dim1 == 0) {
    //         dim1 = m_dim1FC;
    //     }
    //     Ciphertext<DCRTPoly> AdotS = EvalPartialHomDecryption(*ccCKKS, A, m_FHEWtoCKKSswk, dim1, prescale, 0);

    //     // Step 3. Get the ciphertext of B - A*s
    //     Plaintext BPlain = ccCKKS->MakeCKKSPackedPlaintext(b, AdotS->GetNoiseScaleDeg(), AdotS->GetLevel(), nullptr, N / 2);

    //     auto BminusAdotS = ccCKKS->EvalAdd(ccCKKS->EvalNegate(AdotS), BPlain);

    //     if (cryptoParamsCKKS->GetScalingTechnique() == FIXEDMANUAL) {
    //         ccCKKS->ModReduceInPlace(BminusAdotS);
    //     }
    //     else {
    //         if (BminusAdotS->GetNoiseScaleDeg() == 2)
    //             ccCKKS->GetScheme()->ModReduceInternalInPlace(BminusAdotS, BASE_NUM_LEVELS_TO_DROP);
    //     }

    //     // Step 4. Do the modulus reduction: homomorphically evaluate modular function. We do it by using sine approximation.
    //     // auto BminusAdotS2 = BminusAdotS;  // Instead of zeroing out slots which are not of interest as done above

    //     double a_cheby = -1;
    //     double b_cheby = 1;  // The division by K was performed before

    //     // double a_cheby = -K; double b_cheby = K; // Alternatively, do this separately to not lose precision when scaling with everything at once
    //     auto BminusAdotS3 = ccCKKS->EvalChebyshevSeries(BminusAdotS, coefficientsFHEW, a_cheby, b_cheby);

    //     if (cryptoParamsCKKS->GetScalingTechnique() != FIXEDMANUAL) {
    //         ccCKKS->GetScheme()->ModReduceInternalInPlace(BminusAdotS3, BASE_NUM_LEVELS_TO_DROP);
    //     }

    //     enum { BT_ITER = 3 };
    //     for (int32_t j = 1; j < BT_ITER + 1; j++) {
    //         ccCKKS->EvalSquareInPlace(BminusAdotS3); // BminusAdotS3 = ccCKKS->EvalMult(BminusAdotS3, BminusAdotS3);
    //         ccCKKS->EvalAddInPlace(BminusAdotS3, BminusAdotS3);
    //         double scalar = (highPrec) ? std::pow(2.0 / (5.0 * Pi), std::pow(2.0, j - BT_ITER)) :
    //                                      1.0 / std::pow((2.0 * Pi), std::pow(2.0, j - BT_ITER));
    //         ccCKKS->EvalSubInPlace(BminusAdotS3, scalar);
    //         if (cryptoParamsCKKS->GetScalingTechnique() == FIXEDMANUAL) {
    //             ccCKKS->ModReduceInPlace(BminusAdotS3);
    //         }
    //         else {
    //             ccCKKS->GetScheme()->ModReduceInternalInPlace(BminusAdotS3, BASE_NUM_LEVELS_TO_DROP);
    //         }
    //     }

    //     // Apply also the arcsin approximation if larger precision (for messages up to p/4) is desired
    //     if (highPrec && (p > 4)) {
    //         if (n == 32) {
    //             coefficientsFHEW.assign(g_coefficients_cos2pi_4th_16);
    //         }
    //         else {
    //             coefficientsFHEW.assign(g_coefficients_cos2pi_4th_128);
    //         }
    //         auto BminusAdotS4 = ccCKKS->EvalChebyshevSeries(BminusAdotS, coefficientsFHEW, a_cheby, b_cheby);

    //         if (cryptoParamsCKKS->GetScalingTechnique() != FIXEDMANUAL) {
    //             ccCKKS->GetScheme()->ModReduceInternalInPlace(BminusAdotS4, BASE_NUM_LEVELS_TO_DROP);
    //         }

    //         for (int32_t j = 1; j < BT_ITER + 1; j++) {
    //             BminusAdotS4 = ccCKKS->EvalMult(BminusAdotS4, BminusAdotS4);
    //             ccCKKS->EvalAddInPlace(BminusAdotS4, BminusAdotS4);
    //             double scalar = std::pow(1.0 / std::pow(14.0, 1.0 / 3.0), std::pow(2.0, j - BT_ITER));
    //             ccCKKS->EvalSubInPlace(BminusAdotS4, scalar);
    //             if (cryptoParamsCKKS->GetScalingTechnique() == FIXEDMANUAL) {
    //                 ccCKKS->ModReduceInPlace(BminusAdotS4);
    //             }
    //             else {
    //                 ccCKKS->GetScheme()->ModReduceInternalInPlace(BminusAdotS4, BASE_NUM_LEVELS_TO_DROP);
    //             }
    //         }

    //         // Combine the sine and cosine approximations
    //         auto pow2    = ccCKKS->EvalSquare(BminusAdotS4);
    //         auto pow3    = ccCKKS->EvalMult(pow2, BminusAdotS4);
    //         pow2         = ccCKKS->EvalAdd(ccCKKS->EvalMult(pow2, 8.0 / 21.0 * std::pow(14, 2.0 / 3.0)), 40.0 / 21.0);
    //         BminusAdotS4 = ccCKKS->EvalAdd(ccCKKS->EvalMult(BminusAdotS4, 27.0 / 28.0 * std::pow(14, 1.0 / 3.0)), pow3);
    //         ccCKKS->EvalSubInPlace(pow2, BminusAdotS4);
    //         BminusAdotS3 = ccCKKS->EvalMult(BminusAdotS3, pow2);
    //     }

    //     /* For p <= 4 and when we only encrypt bits, we don't need sin(2pi*x)/2pi to approximate x,
    //      * we can directly use sin(0) for 0 and sin(pi/2) for 1.
    //      * Here pmax is actually the plaintext modulus, not the maximum value of the messages that we
    //      * consider. For plaintext modulus > 4, even if we only care about encrypting bits, 2pi is not
    //      * the correct post-scaling factor.
    //      * Moreover, we have to account for the different encoding the end ciphertext should have.
    //      */
    //     double postScale = (p >= 1 && p <= 4) ? (static_cast<double>(2) * Pi) : static_cast<double>(p);
    //     double postBias  = 0.0;
    //     if (pmin != 0) {
    //         postScale *= (pmax - pmin) / 4.0;
    //         postBias = (pmax - pmin) / 4.0;
    //     }

    //     // numValues are set; the rest of values up to N/2 are made zero when creating the plaintext
    //     std::vector<std::complex<double>> postScaleVec(numValues, std::complex<double>(postScale, 0));
    //     std::vector<std::complex<double>> postBiasVec(numValues, std::complex<double>(postBias, 0));

    //     ILDCRTParams<DCRTPoly::Integer> elementParams = *(cryptoParamsCKKS->GetElementParams());

    //     uint32_t towersToDrop = BminusAdotS3->GetLevel() + BminusAdotS3->GetNoiseScaleDeg() - 1;
    //     for (uint32_t i = 0; i < towersToDrop; i++) {
    //         elementParams.PopLastParam();
    //     }

    //     // Use full packing here to clear up the junk in the slots after numValues
    //     auto postScalePlain = ccCKKS->MakeCKKSPackedPlaintext(postScaleVec, 1, towersToDrop, nullptr, N / 2);
    //     auto BminusAdotSres = ccCKKS->EvalMult(BminusAdotS3, postScalePlain);

    //     // Add the plaintext for bias at the correct level and depth
    //     auto postBiasPlain = ccCKKS->MakeCKKSPackedPlaintext(postBiasVec, BminusAdotSres->GetNoiseScaleDeg(),
    //                                                          BminusAdotSres->GetLevel(), nullptr, N / 2);

    //     ccCKKS->EvalAddInPlace(BminusAdotSres, postBiasPlain);

    //     // Additional cleaning for binary messages
    //     if (clean) {
    //         auto square = ccCKKS->EvalSquare(BminusAdotSres);
    //         auto cube   = ccCKKS->EvalMult(square, BminusAdotSres);
    //         ccCKKS->EvalAddInPlace(square, ccCKKS->EvalAdd(square, square));
    //         ccCKKS->EvalAddInPlace(cube, cube);
    //         BminusAdotSres = ccCKKS->EvalAdd(ccCKKS->EvalNegate(cube), square);

    //         if (cryptoParamsCKKS->GetScalingTechnique() == FIXEDMANUAL) {
    //             ccCKKS->ModReduceInPlace(BminusAdotSres);
    //         }
    //         else {
    //             ccCKKS->GetScheme()->ModReduceInternalInPlace(BminusAdotSres, BASE_NUM_LEVELS_TO_DROP);
    //         }
    //     }

    //     // Go back to the sparse encoding if needed
    //     if (isSparse) {
    //         for (uint32_t j = 1; j < N / (2 * slots); j <<= 1) {
    //             auto temp = ccCKKS->EvalAtIndex(BminusAdotSres, j * slots);
    //             ccCKKS->EvalAddInPlace(BminusAdotSres, temp);
    //         }
    //         BminusAdotSres->SetSlots(slots);
    //     }

    //     if (cryptoParamsCKKS->GetScalingTechnique() == FIXEDMANUAL) {
    //         ccCKKS->ModReduceInPlace(BminusAdotSres);
    //     }

    //     return BminusAdotSres;
}

LWEPrivateKey SWITCHCKKSRNS::EvalSchemeSwitchingSetup(const SchSwchParams& params) {
    // CKKS to FHEW
    auto lwesk = EvalCKKStoFHEWSetup(params);

    // FHEW to CKKS
    // Save the parameters to be used in EvalSchemeSwitchingKeyGen
    m_argmin = params.GetComputeArgmin();
    m_oneHot = params.GetOneHotEncoding();
    m_alt    = params.GetUseAltArgmin();

    // Set parameters for linear transform for FHEW to CKKS
    if (!m_argmin || (m_argmin && m_alt)) {
        m_numCtxts = (params.GetNumValues() == 0) ? m_numSlotsCKKS : params.GetNumValues();
    }
    else {  // argmin not in the alternative mode
        m_numCtxts = (params.GetNumValues() == 0) ? m_numSlotsCKKS / 2 : params.GetNumValues() / 2;
    }

    // There are multiple dim1's required in argmin, but they are specified individually in EvalSchemeSwitchingKeyGen
    m_dim1FC = (params.GetBStepLTrFHEWtoCKKS() == 0) ? getRatioBSGSLT(m_numCtxts) : params.GetBStepLTrFHEWtoCKKS();
    m_LFC    = params.GetLevelLTrFHEWtoCKKS();

    return lwesk;
}

std::shared_ptr<std::map<usint, EvalKey<DCRTPoly>>> SWITCHCKKSRNS::EvalSchemeSwitchingKeyGen(
    const KeyPair<DCRTPoly>& keyPair, ConstLWEPrivateKey& lwesk) {
    auto privateKey = keyPair.secretKey;
    auto publicKey  = keyPair.publicKey;

    const auto cryptoParams = std::dynamic_pointer_cast<CryptoParametersCKKSRNS>(privateKey->GetCryptoParameters());

    if (cryptoParams->GetKeySwitchTechnique() != HYBRID)
        OPENFHE_THROW("CKKS to FHEW scheme switching is only supported for the Hybrid key switching method.");
#if NATIVEINT == 128 && !defined(__EMSCRIPTEN__)
    if (cryptoParams->GetScalingTechnique() == FLEXIBLEAUTO || cryptoParams->GetScalingTechnique() == FLEXIBLEAUTOEXT)
        OPENFHE_THROW("128-bit CKKS to FHEW scheme switching is supported for FIXEDMANUAL and FIXEDAUTO methods only.");
#endif

    auto ccCKKS = privateKey->GetCryptoContext();

    uint32_t M       = ccCKKS->GetCyclotomicOrder();
    uint32_t slots   = m_numSlotsCKKS;
    uint32_t n       = lwesk->GetElement().GetLength();
    uint32_t ringDim = ccCKKS->GetRingDimension();

    // Intermediate cryptocontext for CKKS to FHEW
    auto keys2 = m_ccKS->KeyGen();

    Plaintext ptxtZeroKS = m_ccKS->MakeCKKSPackedPlaintext(std::vector<double>{0.0}, 1, 0, nullptr, slots);
    m_ctxtKS             = m_ccKS->Encrypt(keys2.publicKey, ptxtZeroKS);

    // Compute switching key between RLWE and LWE via the intermediate cryptocontext, keep it in RLWE form
    m_CKKStoFHEWswk = switchingKeyGenRLWEcc(keys2.secretKey, privateKey, lwesk);

    // Generate FHEW to CKKS switching key, i.e., CKKS encryption of FHEW secret key. Pad up to the closest power of two
    uint32_t n_po2     = 1 << static_cast<uint32_t>(std::ceil(std::log2(n)));
    auto skLWEElements = lwesk->GetElement();
    std::vector<std::complex<double>> skLWEDouble(n_po2);
    for (uint32_t i = 0; i < n; i++) {
        auto tmp = skLWEElements[i].ConvertToDouble();
        if (tmp == lwesk->GetModulus().ConvertToInt() - 1)
            tmp = -1;
        skLWEDouble[i] = std::complex<double>(tmp, 0);
    }

    // Check encoding and specify the number of slots, otherwise, if batchsize is set and is smaller, it will throw an error.
    Plaintext skLWEPlainswk;
    if (cryptoParams->GetScalingTechnique() == FLEXIBLEAUTOEXT)
        skLWEPlainswk = ccCKKS->MakeCKKSPackedPlaintext(Fill(skLWEDouble, ringDim / 2), 1, BASE_NUM_LEVELS_TO_DROP,
                                                        nullptr, ringDim / 2);
    else
        skLWEPlainswk = ccCKKS->MakeCKKSPackedPlaintext(Fill(skLWEDouble, ringDim / 2), 1, 0, nullptr, ringDim / 2);

    m_FHEWtoCKKSswk = ccCKKS->Encrypt(publicKey, skLWEPlainswk);

    // Compute automorphism keys

    /* CKKS to FHEW */
    // Compute indices for rotations for slotToCoeff transform
    std::vector<int32_t> indexRotationS2C = FindLTRotationIndicesSwitch(m_dim1CF, M, slots);
    indexRotationS2C.emplace_back(static_cast<int32_t>(slots));

    // Compute indices for rotations for sparse packing
    if (ringDim > 2 * slots) {  // if the encoding is full, this does not execute
        indexRotationS2C.reserve(indexRotationS2C.size() + GetMSB(ringDim) - 2 + GetMSB(slots) - 1);
        for (uint32_t i = 1; i < ringDim / 2; i <<= 1) {
            indexRotationS2C.emplace_back(static_cast<int32_t>(i));
            if (i <= slots)
                indexRotationS2C.emplace_back(-static_cast<int32_t>(i));
        }
    }

    /* FHEW to CKKS */
    std::vector<int32_t> indexRotationHomDec;
    std::vector<int32_t> indexRotationArgmin;

    if (!m_argmin || (m_argmin && m_alt)) {
        // Compute indices for rotations for homomorphic decryption
        indexRotationHomDec = FindLTRotationIndicesSwitch(m_dim1FC, M, m_numCtxts);

        // If the linear transform is wide instead of tall, we need extra rotations
        if (m_numCtxts < n_po2) {
            uint32_t logl = lbcrypto::GetMSB(n_po2 / m_numCtxts) - 1;  // These are powers of two, so log(l) is integer
            indexRotationHomDec.reserve(indexRotationHomDec.size() + logl);
            for (size_t j = 1; j <= logl; ++j) {
                indexRotationHomDec.emplace_back(m_numCtxts * (1 << (j - 1)));
            }
        }
        if (m_argmin) {
            // Rotations for postprocessing after a level of the binary tree
            indexRotationArgmin.reserve(GetMSB(m_numCtxts) - 2);
            for (uint32_t i = 1; i < m_numCtxts; i <<= 1) {
                indexRotationArgmin.emplace_back(static_cast<int32_t>(m_numCtxts / (2 * i)));
            }
        }
    }
    else {  // argmin not in the alternative mode
        // Compute indices for rotations for all homomorphic decryptions for the levels of the tree
        indexRotationHomDec = FindLTRotationIndicesSwitchArgmin(M, m_numCtxts, n_po2);

        // Rotations for postprocessing after a level of the binary tree
        indexRotationArgmin.reserve(GetMSB(m_numCtxts) - 1 + 2 * (GetMSB(m_numCtxts) - 1));
        for (uint32_t i = 1; i < 2 * m_numCtxts; i <<= 1) {
            indexRotationArgmin.emplace_back(static_cast<int32_t>(m_numCtxts / (2 * i)));
            indexRotationArgmin.emplace_back(-static_cast<int32_t>(m_numCtxts / (2 * i)));
            if (i > 1) {
                for (uint32_t j = 2 * m_numCtxts / i; j < 2 * m_numCtxts; j <<= 1)
                    indexRotationArgmin.emplace_back(-static_cast<int32_t>(j));
            }
        }
    }

    // Compute indices for rotations to bring back the final CKKS ciphertext encoding to slots
    if (ringDim > 2 * slots) {  // if the encoding is full, this does not execute
        indexRotationHomDec.reserve(indexRotationHomDec.size() + GetMSB(ringDim) - 2);
        for (uint32_t j = 1; j < ringDim / (2 * slots); j <<= 1) {
            indexRotationHomDec.emplace_back(j * slots);
        }
    }

    // Combine the indices lists
    indexRotationS2C.reserve(indexRotationS2C.size() + indexRotationHomDec.size() + indexRotationArgmin.size());
    indexRotationS2C.insert(indexRotationS2C.end(), indexRotationHomDec.begin(), indexRotationHomDec.end());
    indexRotationS2C.insert(indexRotationS2C.end(), indexRotationArgmin.begin(), indexRotationArgmin.end());

    // Remove possible duplicates and zero
    sort(indexRotationS2C.begin(), indexRotationS2C.end());
    indexRotationS2C.erase(unique(indexRotationS2C.begin(), indexRotationS2C.end()), indexRotationS2C.end());
    indexRotationS2C.erase(std::remove(indexRotationS2C.begin(), indexRotationS2C.end(), 0), indexRotationS2C.end());

    auto algo     = ccCKKS->GetScheme();
    auto evalKeys = algo->EvalAtIndexKeyGen(publicKey, privateKey, indexRotationS2C);

    // Compute conjugation key
    auto conjKey       = ConjugateKeyGen(privateKey);
    (*evalKeys)[M - 1] = conjKey;

    // Compute multiplication key
    ccCKKS->EvalMultKeyGen(privateKey);

    // Compute automorphism keys if we don't want one hot encoding for argmin
    if (m_argmin && (m_oneHot == false)) {
        ccCKKS->EvalSumKeyGen(privateKey);
    }

    /* FHEW computations */
    // Generate the bootstrapping keys (refresh and switching keys)
    m_ccLWE->BTKeyGen(lwesk);

    return evalKeys;
}

void SWITCHCKKSRNS::EvalCompareSwitchPrecompute(const CryptoContextImpl<DCRTPoly>& ccCKKS, uint32_t pLWE,
                                                double scaleSign, bool unit) {
    double scaleCF = 1.0;
    if ((pLWE != 0) && (!unit)) {  // The messages are already scaled between 0 and 1, no need to divide by pLWE
        scaleCF = 1.0 / pLWE;
    }
    // Else perform no scaling; the implicit FHEW plaintext modulus will be m_modulus_CKKS_initial / scFactor
    scaleCF *= scaleSign;

    EvalCKKStoFHEWPrecompute(ccCKKS, scaleCF);
}

Ciphertext<DCRTPoly> SWITCHCKKSRNS::EvalCompareSchemeSwitching(ConstCiphertext<DCRTPoly> ciphertext1,
                                                               ConstCiphertext<DCRTPoly> ciphertext2, uint32_t numCtxts,
                                                               uint32_t numSlots, uint32_t pLWE, double scaleSign,
                                                               bool unit, bool clean) {
    auto ccCKKS             = ciphertext1->GetCryptoContext();
    const auto cryptoParams = std::dynamic_pointer_cast<CryptoParametersCKKSRNS>(ccCKKS->GetCryptoParameters());

    auto cDiff = ccCKKS->EvalSub(ciphertext1, ciphertext2);

    if (unit) {
        if (pLWE == 0)
            OPENFHE_THROW("To scale to the unit circle, pLWE must be non-zero.");
        else {
            cDiff = ccCKKS->EvalMult(cDiff, 1.0 / static_cast<double>(pLWE));
            cDiff = ccCKKS->Rescale(cDiff);
        }
    }

    // The precomputation has already been performed, but if it is scaled differently than desired, recompute it
    if (pLWE != 0) {
        double scaleCF = 1.0;
        if ((pLWE != 0) && (!unit)) {
            scaleCF = 1.0 / pLWE;
        }
        scaleCF *= scaleSign;

        EvalCKKStoFHEWPrecompute(*ccCKKS, scaleCF);
    }

    auto LWECiphertexts = EvalCKKStoFHEW(cDiff, numCtxts);

    std::vector<LWECiphertext> cSigns(LWECiphertexts.size());
#pragma omp parallel for
    for (uint32_t i = 0; i < LWECiphertexts.size(); i++) {
        cSigns[i] = m_ccLWE->EvalSign(LWECiphertexts[i], true);
    }

    return EvalFHEWtoCKKS(cSigns, numCtxts, numSlots, 4, -1.0, 1.0, 0, clean, false);
}

std::vector<Ciphertext<DCRTPoly>> SWITCHCKKSRNS::EvalMinSchemeSwitching(ConstCiphertext<DCRTPoly> ciphertext,
                                                                        PublicKey<DCRTPoly> publicKey,
                                                                        uint32_t numValues, uint32_t numSlots,
                                                                        uint32_t pLWE, double scaleSign, bool clean) {
    auto cc                 = ciphertext->GetCryptoContext();
    const auto cryptoParams = std::dynamic_pointer_cast<CryptoParametersRNS>(ciphertext->GetCryptoParameters());

    // The precomputation has already been performed, but if it is scaled differently than desired, recompute it
    if (pLWE != 0) {
        double scaleCF = 1.0 / pLWE;
        scaleCF *= scaleSign;
        EvalCKKStoFHEWPrecompute(*cc, scaleCF);
    }

    uint32_t towersToDrop = 12 + clean * 2;  // How many levels are consumed in the EvalFHEWtoCKKS
    uint32_t slots        = (numSlots == 0) ? m_numSlotsCKKS : numSlots;

    Plaintext pInd;
    if (m_oneHot) {
        std::vector<std::complex<double>> ind(numValues, 1.0);
        pInd = cc->MakeCKKSPackedPlaintext(ind, 1, towersToDrop, nullptr, slots);
    }
    else {
        std::vector<std::complex<double>> ind(numValues);
        std::iota(ind.begin(), ind.end(), 0);
        pInd = cc->MakeCKKSPackedPlaintext(ind, 1, towersToDrop, nullptr, slots);
    }
    Ciphertext<DCRTPoly> cInd          = cc->Encrypt(publicKey, pInd);
    Ciphertext<DCRTPoly> newCiphertext = ciphertext->Clone();

    for (uint32_t M = 1; M < numValues; M <<= 1) {
        // Compute CKKS ciphertext encoding difference of the first numValues
        auto cDiff = cc->EvalSub(newCiphertext, cc->EvalAtIndex(newCiphertext, numValues / (2 * M)));

        // Transform the ciphertext from CKKS to FHEW
        auto cTemp = EvalCKKStoFHEW(cDiff, numValues / (2 * M));

        // Evaluate the sign
        // We always assume for the moment that numValues is a power of 2
        std::vector<LWECiphertext> LWESign(numValues / (2 * M));
#pragma omp parallel for
        for (uint32_t j = 0; j < numValues / (2 * M); j++) {
            LWESign[j] = m_ccLWE->EvalSign(cTemp[j], true);
        }

        // Scheme switching from FHEW to CKKS
        auto dim1    = getRatioBSGSLT(numValues / (2 * M));
        auto cSelect = EvalFHEWtoCKKS(LWESign, numValues / (2 * M), numSlots, 4, -1.0, 1.0, dim1, clean, false);

        std::vector<std::complex<double>> ones(numValues / (2 * M), 1.0);
        Plaintext ptxtOnes = cc->MakeCKKSPackedPlaintext(ones, 1, 0, nullptr, slots);
        cc->EvalAddInPlace(cSelect,
                           cc->EvalAtIndex(cc->EvalSub(ptxtOnes, cSelect), -static_cast<int32_t>(numValues / (2 * M))));

        auto cExpandSelect = cSelect;
        if (M > 1) {
            for (uint32_t j = numValues / M; j < numValues; j <<= 1)
                cc->EvalAddInPlace(cExpandSelect, cc->EvalAtIndex(cExpandSelect, -static_cast<int32_t>(j)));
        }

        // Update the ciphertext of values and the indicator
        newCiphertext = cc->EvalMult(newCiphertext, cExpandSelect);
        cc->EvalAddInPlace(newCiphertext, cc->EvalAtIndex(newCiphertext, numValues / (2 * M)));
        if (cryptoParams->GetScalingTechnique() == FIXEDMANUAL) {
            cc->ModReduceInPlace(newCiphertext);
        }

        cInd = cc->EvalMult(cInd, cExpandSelect);
        if (cryptoParams->GetScalingTechnique() == FIXEDMANUAL) {
            cc->ModReduceInPlace(cInd);
        }
    }
    // After computing the minimum and argument
    if (!m_oneHot) {
        cInd = cc->EvalSum(cInd, numValues);
    }

    std::vector<Ciphertext<DCRTPoly>> cRes{newCiphertext, cInd};

    return cRes;
}

std::vector<Ciphertext<DCRTPoly>> SWITCHCKKSRNS::EvalMinSchemeSwitchingAlt(ConstCiphertext<DCRTPoly> ciphertext,
                                                                           PublicKey<DCRTPoly> publicKey,
                                                                           uint32_t numValues, uint32_t numSlots,
                                                                           uint32_t pLWE, double scaleSign,
                                                                           bool clean) {
    auto cc                 = ciphertext->GetCryptoContext();
    const auto cryptoParams = std::dynamic_pointer_cast<CryptoParametersRNS>(ciphertext->GetCryptoParameters());

    // The precomputation has already been performed, but if it is scaled differently than desired, recompute it
    if (pLWE != 0) {
        double scaleCF = 1.0 / pLWE;
        scaleCF *= scaleSign;
        EvalCKKStoFHEWPrecompute(*cc, scaleCF);
    }

    uint32_t towersToDrop =
        12 + clean * 2;  // How many levels are consumed in the EvalFHEWtoCKKS, for binary FHEW output.
    uint32_t slots = (numSlots == 0) ? m_numSlotsCKKS : numSlots;

    Plaintext pInd;
    if (m_oneHot) {
        std::vector<std::complex<double>> ind(numValues, 1.0);
        pInd = cc->MakeCKKSPackedPlaintext(ind, 1, towersToDrop, nullptr, slots);
    }
    else {
        std::vector<std::complex<double>> ind(numValues);
        std::iota(ind.begin(), ind.end(), 0);
        pInd = cc->MakeCKKSPackedPlaintext(ind, 1, towersToDrop, nullptr, slots);
    }
    Ciphertext<DCRTPoly> cInd          = cc->Encrypt(publicKey, pInd);
    Ciphertext<DCRTPoly> newCiphertext = ciphertext->Clone();

    for (uint32_t M = 1; M < numValues; M <<= 1) {
        // Compute CKKS ciphertext encoding difference of the first numValues
        auto cDiff = cc->EvalSub(newCiphertext, cc->EvalAtIndex(newCiphertext, numValues / (2 * M)));

        // Transform the ciphertext from CKKS to FHEW
        auto cTemp = EvalCKKStoFHEW(cDiff, numValues / (2 * M));

        // Evaluate the sign
        // We always assume for the moment that numValues is a power of 2
        std::vector<LWECiphertext> LWESign(numValues);
#pragma omp parallel for
        for (uint32_t j = 0; j < numValues / (2 * M); j++) {
            LWECiphertext tempSign    = m_ccLWE->EvalSign(cTemp[j], true);
            LWECiphertext negTempSign = std::make_shared<LWECiphertextImpl>(*tempSign);
            m_ccLWE->GetLWEScheme()->EvalAddConstEq(negTempSign, negTempSign->GetModulus() >> 1);  // "negated" tempSign
            for (uint32_t i = 0; i < 2 * M; i += 2) {
                LWESign[i * numValues / (2 * M) + j]       = tempSign;
                LWESign[(i + 1) * numValues / (2 * M) + j] = negTempSign;
            }
        }

        // Scheme switching from FHEW to CKKS
        auto dim1          = getRatioBSGSLT(numValues);
        auto cExpandSelect = EvalFHEWtoCKKS(LWESign, numValues, numSlots, 4, -1.0, 1.0, dim1, clean, false);

        // Update the ciphertext of values and the indicator
        newCiphertext = cc->EvalMult(newCiphertext, cExpandSelect);
        cc->EvalAddInPlace(newCiphertext, cc->EvalAtIndex(newCiphertext, numValues / (2 * M)));

        if (cryptoParams->GetScalingTechnique() == FIXEDMANUAL) {
            cc->ModReduceInPlace(newCiphertext);
        }

        cInd = cc->EvalMult(cInd, cExpandSelect);
        if (cryptoParams->GetScalingTechnique() == FIXEDMANUAL) {
            cc->ModReduceInPlace(cInd);
        }
    }
    // After computing the minimum and argument
    if (!m_oneHot) {
        cInd = cc->EvalSum(cInd, numValues);
    }

    std::vector<Ciphertext<DCRTPoly>> cRes{newCiphertext, cInd};

    return cRes;
}

std::vector<Ciphertext<DCRTPoly>> SWITCHCKKSRNS::EvalMaxSchemeSwitching(ConstCiphertext<DCRTPoly> ciphertext,
                                                                        PublicKey<DCRTPoly> publicKey,
                                                                        uint32_t numValues, uint32_t numSlots,
                                                                        uint32_t pLWE, double scaleSign, bool clean) {
    auto cc                 = ciphertext->GetCryptoContext();
    const auto cryptoParams = std::dynamic_pointer_cast<CryptoParametersRNS>(ciphertext->GetCryptoParameters());

    // The precomputation has already been performed, but if it is scaled differently than desired, recompute it
    if (pLWE != 0) {
        double scaleCF = 1.0 / pLWE;
        scaleCF *= scaleSign;
        EvalCKKStoFHEWPrecompute(*cc, scaleCF);
    }

    uint32_t towersToDrop =
        12 + clean * 2;  // How many levels are consumed in the EvalFHEWtoCKKS, for binary FHEW output.
    uint32_t slots = (numSlots == 0) ? m_numSlotsCKKS : numSlots;

    Plaintext pInd;
    if (m_oneHot) {
        std::vector<std::complex<double>> ind(numValues, 1.0);
        pInd = cc->MakeCKKSPackedPlaintext(ind, 1, towersToDrop, nullptr, slots);
    }
    else {
        std::vector<std::complex<double>> ind(numValues);
        std::iota(ind.begin(), ind.end(), 0);
        pInd = cc->MakeCKKSPackedPlaintext(ind, 1, towersToDrop, nullptr, slots);
    }
    Ciphertext<DCRTPoly> cInd          = cc->Encrypt(publicKey, pInd);
    Ciphertext<DCRTPoly> newCiphertext = ciphertext->Clone();

    for (uint32_t M = 1; M < numValues; M <<= 1) {
        // Compute CKKS ciphertext encoding difference of the first numValues
        auto cDiff = cc->EvalSub(newCiphertext, cc->EvalAtIndex(newCiphertext, numValues / (2 * M)));

        // Transform the ciphertext from CKKS to FHEW
        auto cTemp = EvalCKKStoFHEW(cDiff, numValues / (2 * M));

        // Evaluate the sign
        // We always assume for the moment that numValues is a power of 2
        std::vector<LWECiphertext> LWESign(numValues / (2 * M));
#pragma omp parallel for
        for (uint32_t j = 0; j < numValues / (2 * M); j++) {
            LWESign[j] = m_ccLWE->EvalSign(cTemp[j], true);
        }

        // Scheme switching from FHEW to CKKS
        auto dim1    = getRatioBSGSLT(numValues / (2 * M));
        auto cSelect = EvalFHEWtoCKKS(LWESign, numValues / (2 * M), numSlots, 4, -1.0, 1.0, dim1, clean, false);

        std::vector<std::complex<double>> ones(numValues / (2 * M), 1.0);
        Plaintext ptxtOnes = cc->MakeCKKSPackedPlaintext(ones, 1, 0, nullptr, slots);
        cSelect            = cc->EvalAdd(cc->EvalSub(ptxtOnes, cSelect),
                                         cc->EvalAtIndex(cSelect, -static_cast<int32_t>(numValues / (2 * M))));

        auto cExpandSelect = cSelect;
        if (M > 1) {
            for (uint32_t j = numValues / M; j < numValues; j <<= 1)
                cc->EvalAddInPlace(cExpandSelect, cc->EvalAtIndex(cExpandSelect, -static_cast<int32_t>(j)));
        }

        // Update the ciphertext of values and the indicator
        newCiphertext = cc->EvalMult(newCiphertext, cExpandSelect);
        cc->EvalAddInPlace(newCiphertext, cc->EvalAtIndex(newCiphertext, numValues / (2 * M)));

        if (cryptoParams->GetScalingTechnique() == FIXEDMANUAL) {
            cc->ModReduceInPlace(newCiphertext);
        }

        cInd = cc->EvalMult(cInd, cExpandSelect);
        if (cryptoParams->GetScalingTechnique() == FIXEDMANUAL) {
            cc->ModReduceInPlace(cInd);
        }
    }
    // After computing the minimum and argument
    if (!m_oneHot) {
        cInd = cc->EvalSum(cInd, numValues);
    }

    std::vector<Ciphertext<DCRTPoly>> cRes{newCiphertext, cInd};

    return cRes;
}

std::vector<Ciphertext<DCRTPoly>> SWITCHCKKSRNS::EvalMaxSchemeSwitchingAlt(ConstCiphertext<DCRTPoly> ciphertext,
                                                                           PublicKey<DCRTPoly> publicKey,
                                                                           uint32_t numValues, uint32_t numSlots,
                                                                           uint32_t pLWE, double scaleSign,
                                                                           bool clean) {
    auto cc                 = ciphertext->GetCryptoContext();
    const auto cryptoParams = std::dynamic_pointer_cast<CryptoParametersRNS>(ciphertext->GetCryptoParameters());

    // The precomputation has already been performed, but if it is scaled differently than desired, recompute it
    if (pLWE != 0) {
        double scaleCF = 1.0 / pLWE;
        scaleCF *= scaleSign;
        EvalCKKStoFHEWPrecompute(*cc, scaleCF);
    }

    uint32_t towersToDrop =
        12 + clean * 2;  // How many levels are consumed in the EvalFHEWtoCKKS, for binary FHEW output
    uint32_t slots = (numSlots == 0) ? m_numSlotsCKKS : numSlots;

    Plaintext pInd;
    if (m_oneHot) {
        std::vector<std::complex<double>> ind(numValues, 1.0);
        pInd = cc->MakeCKKSPackedPlaintext(ind, 1, towersToDrop, nullptr, slots);
    }
    else {
        std::vector<std::complex<double>> ind(numValues);
        std::iota(ind.begin(), ind.end(), 0);
        pInd = cc->MakeCKKSPackedPlaintext(ind, 1, towersToDrop, nullptr, slots);
    }
    Ciphertext<DCRTPoly> cInd          = cc->Encrypt(publicKey, pInd);
    Ciphertext<DCRTPoly> newCiphertext = ciphertext->Clone();

    for (uint32_t M = 1; M < numValues; M <<= 1) {
        // Compute CKKS ciphertext encoding difference of the first numValues
        auto cDiff = cc->EvalSub(newCiphertext, cc->EvalAtIndex(newCiphertext, numValues / (2 * M)));

        // Transform the ciphertext from CKKS to FHEW
        auto cTemp = EvalCKKStoFHEW(cDiff, numValues / (2 * M));

        // Evaluate the sign
        // We always assume for the moment that numValues is a power of 2
        std::vector<LWECiphertext> LWESign(numValues);
#pragma omp parallel for
        for (uint32_t j = 0; j < numValues / (2 * M); j++) {
            LWECiphertext tempSign    = m_ccLWE->EvalSign(cTemp[j], true);
            LWECiphertext negTempSign = std::make_shared<LWECiphertextImpl>(*tempSign);
            m_ccLWE->GetLWEScheme()->EvalAddConstEq(negTempSign, negTempSign->GetModulus() >> 1);  // "negated" tempSign
            for (uint32_t i = 0; i < 2 * M; i += 2) {
                LWESign[i * numValues / (2 * M) + j]       = negTempSign;
                LWESign[(i + 1) * numValues / (2 * M) + j] = tempSign;
            }
        }

        // Scheme switching from FHEW to CKKS
        auto dim1          = getRatioBSGSLT(numValues);
        auto cExpandSelect = EvalFHEWtoCKKS(LWESign, numValues, numSlots, 4, -1.0, 1.0, dim1, clean, false);

        // Update the ciphertext of values and the indicator
        newCiphertext = cc->EvalMult(newCiphertext, cExpandSelect);
        cc->EvalAddInPlace(newCiphertext, cc->EvalAtIndex(newCiphertext, numValues / (2 * M)));

        if (cryptoParams->GetScalingTechnique() == FIXEDMANUAL) {
            cc->ModReduceInPlace(newCiphertext);
        }

        cInd = cc->EvalMult(cInd, cExpandSelect);
        if (cryptoParams->GetScalingTechnique() == FIXEDMANUAL) {
            cc->ModReduceInPlace(cInd);
        }
    }
    // After computing the minimum and argument
    if (!m_oneHot) {
        cInd = cc->EvalSum(cInd, numValues);
    }

    std::vector<Ciphertext<DCRTPoly>> cRes{newCiphertext, cInd};

    return cRes;
}

}  // namespace lbcrypto
